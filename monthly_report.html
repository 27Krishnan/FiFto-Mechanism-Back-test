<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monthly Trading Report</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <style>
        :root {
            /* Professional Premium Dark (Slate Theme) */
            --bg-color: #0f172a;
            --surface-color: #1e293b;
            --surface-hover: #334155;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --accent-color: #38bdf8;
            --success-color: #10b981;
            --error-color: #ef4444;
            --border-color: #334155;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --transition: all 0.2s ease-in-out;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            margin: 0;
            padding: 20px;
            font-size: 14px;
            min-height: 100vh;
            font-variant-numeric: tabular-nums;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: block;
            min-height: 80vh;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        h1 {
            color: var(--text-primary);
            margin: 0;
            font-weight: 800;
            font-size: 1.5rem;
            letter-spacing: -0.025em;
            text-transform: uppercase;
        }

        .controls {
            padding: 10px;
            background-color: var(--surface-color);
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid var(--border-color);
        }

        /* Tabs */
        .tab-nav {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .tab-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1rem;
            font-weight: 500;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 20px;
            transition: var(--transition);
        }

        .tab-btn:hover {
            color: var(--text-primary);
            background: var(--surface-hover);
        }

        .tab-btn.active {
            color: #000;
            background: var(--accent-color);
            font-weight: 600;
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.3);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Stats Dashboard */
        .stats-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stats-card {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .stats-card:hover {
            transform: translateY(-3px);
            border-color: var(--accent-color);
        }

        .stats-card-title {
            color: var(--text-secondary);
            font-size: 0.85em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 10px;
        }

        .stats-card-value {
            color: var(--text-primary);
            font-size: 2em;
            font-weight: 700;
            margin-bottom: 12px;
        }

        .stats-card-sub {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-top: auto;
            display: flex;
            justify-content: flex-start;
            align-items: center;
        }

        /* Common Components */
        .glass-panel {
            background: var(--surface-color);
            border-radius: 12px;
            padding: 24px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .section-title {
            color: var(--text-primary);
            font-weight: 700;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            width: 100%;
        }

        th,
        td {
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            color: var(--text-secondary);
            font-weight: 600;
            background-color: rgba(0, 0, 0, 0.2);
            text-transform: uppercase;
            font-size: 0.75em;
        }

        tr:hover {
            background-color: var(--surface-hover);
        }

        .text-green {
            color: var(--success-color);
        }

        .text-red {
            color: var(--error-color);
        }

        .primary-btn {
            background: var(--success-color);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 700;
            cursor: pointer;
            transition: var(--transition);
        }

        .primary-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        input[type="text"] {
            background: #0f172a;
            border: 1px solid var(--border-color);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            outline: none;
        }

        input[type="text"]:focus {
            border-color: var(--accent-color);
        }

        footer {
            text-align: center;
            color: var(--text-secondary);
            margin-top: 40px;
            font-size: 0.8em;
        }

        .clickable-row {
            cursor: pointer;
            transition: background 0.2s;
        }

        .clickable-row:hover {
            background-color: var(--surface-hover);
        }
    </style>
</head>

<body>

    <div class="container">
        <header>
            <h1 id="reportTitle">FiFto Backtest report</h1>
            <div id="fileControls" class="controls">
                <div id="fileControlsList"
                    style="display: flex; gap: 15px; overflow-x: auto; align-items: center; margin-right: 15px; max-width: 60%; padding-bottom: 2px;">
                    <!-- Dynamic File Controls Injected Here -->
                    <span style="font-size: 0.8em; color: var(--text-secondary);">Upload files to see controls</span>
                </div>
                <input type="file" id="csvFileInput" accept=".csv, .xlsx, .xls, .json" multiple>
                <button id="exportBtn" onclick="exportPortfolio()" class="primary-btn" style="display: none;">Export
                    JSON</button>
            </div>
        </header>

        <!-- Tab Navigation -->
        <nav class="tab-nav">
            <button class="tab-btn active" onclick="switchTab('dashboard')">Dashboard</button>
            <button class="tab-btn" onclick="switchTab('charts')">Analysis</button>
            <button class="tab-btn" onclick="switchTab('history')">History</button>
        </nav>

        <!-- TAB 1: DASHBOARD -->
        <div id="tab-dashboard" class="tab-content active">
            <div class="stats-dashboard">
                <!-- Card 1: Performance -->
                <div class="stats-card">
                    <div class="stats-card-title">Performance</div>
                    <div class="stats-card-value" id="winRateDisplay">--%</div>
                    <div class="stats-card-sub">
                        <span>Wins: <span id="winningTrades" class="text-green">0</span></span>
                    </div>
                    <div class="stats-card-sub" style="margin-top: 5px;">
                        <span>Losses: <span id="losingTrades" class="text-red">0</span></span>
                    </div>
                    <div class="stats-card-sub" style="margin-top: 5px; font-size: 0.8em; opacity: 0.7;">
                        Total Trades: <span id="totalTrades">--</span>
                    </div>
                </div>

                <!-- Card 2: Net Profit -->
                <div class="stats-card">
                    <div class="stats-card-title">Total Net Profit</div>
                    <div class="stats-card-value" id="totalNetProfit">--</div>
                    <div class="stats-card-sub">
                        <span>Gross P: <span id="grossProfit" class="text-green">--</span></span>
                    </div>
                    <div class="stats-card-sub" style="margin-top: 5px;">
                        <span>Gross L: <span id="grossLoss" class="text-red">--</span></span>
                    </div>
                </div>

                <!-- Card 3: Averages -->
                <div class="stats-card">
                    <div class="stats-card-title">Average Trade</div>
                    <div class="stats-card-value" id="avgProfit">--</div>
                    <div class="stats-card-sub">
                        <span>Avg Win: <span id="avgWinner" class="text-green">--</span></span>
                    </div>
                    <div class="stats-card-sub" style="margin-top: 5px;">
                        <span>Avg Loss: <span id="avgLoser" class="text-red">--</span></span>
                    </div>
                </div>

                <!-- Card 4: Drawdown -->
                <div class="stats-card">
                    <div class="stats-card-title">Max Drawdown</div>
                    <div class="stats-card-value text-red" id="maxDrawdown">--</div>
                    <div class="stats-card-sub" style="flex-direction: column; align-items: flex-start;">
                        <span id="maxDrawdownDateRange" style="font-size: 0.8em; opacity: 0.7;"></span>
                    </div>
                </div>

                <!-- Card: Max Run-up (New) -->
                <div class="stats-card">
                    <div class="stats-card-title">Max Run-up</div>
                    <div class="stats-card-value text-green" id="maxRunup">--</div>
                    <div class="stats-card-sub" style="flex-direction: column; align-items: flex-start;">
                        <span id="maxRunupDateRange" style="font-size: 0.8em; opacity: 0.7;"></span>
                    </div>
                </div>

                <!-- Card 5: Streaks -->
                <div class="stats-card">
                    <div class="stats-card-title">Best Streak</div>
                    <div class="stats-card-value text-green" id="maxWinStreak" style="font-size: 1.5em;">--</div>
                    <div class="stats-card-sub">
                        <span id="maxWinStreakDate" style="font-size: 0.9em; opacity: 0.7;"></span>
                    </div>
                    <div class="stats-card-sub">
                        <span>Amount: <span id="maxWinStreakAmount" class="text-green"
                                style="font-weight: 700;">--</span></span>
                    </div>
                </div>

                <!-- Card 6: Worst Streak -->
                <div class="stats-card">
                    <div class="stats-card-title">Worst Streak</div>
                    <div class="stats-card-value text-red" id="maxLoseStreak" style="font-size: 1.5em;">--</div>
                    <div class="stats-card-sub">
                        <span id="maxLoseStreakDate" style="font-size: 0.9em; opacity: 0.7;"></span>
                    </div>
                    <div class="stats-card-sub">
                        <span>Amount: <span id="maxLoseStreakAmount" class="text-red"
                                style="font-weight: 700;">--</span></span>
                    </div>
                </div>

                <!-- Card 7: Run-up Target Calculator -->
                <div class="stats-card">
                    <div class="stats-card-title">Run-up Target</div>
                    <div style="margin-bottom: 10px;">
                        <input type="number" id="runupTargetInput" placeholder="Enter INR Target (e.g. 1000)"
                            style="width: 100%; box-sizing: border-box; background: var(--bg-color); border: 1px solid var(--border-color); padding: 8px; border-radius: 6px; color: var(--text-primary);"
                            oninput="calculateTargetHit()">
                    </div>
                    <div class="stats-card-value" id="runupTargetResult" style="font-size: 1.2em;">-- / --</div>
                    <div class="stats-card-sub" id="runupTargetPercent" style="color: var(--accent-color);">
                        --%
                    </div>
                </div>
            </div>

            <!-- Utilities -->
            <section id="utilities" style="border-top: 1px solid var(--border-color); padding-top: 20px;">
                <div class="glass-panel" style="max-width: 600px; margin: 0 auto;">
                    <div class="section-title">Portfolio Library</div>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <input type="text" id="portfolioNameInput" placeholder="Save current portfolio as..."
                            style="flex: 1;">
                        <button onclick="saveToLibrary()" class="primary-btn">Save</button>
                    </div>
                    <ul id="portfolioList"
                        style="list-style: none; padding: 0; margin: 0; max-height: 200px; overflow-y: auto;">
                        <!-- Items injected here -->
                    </ul>
                </div>
            </section>
        </div>

        <!-- TAB 2: ANALYSIS -->
        <div id="tab-charts" class="tab-content">
            <div class="glass-panel">
                <div class="section-title">Equity Curve</div>
                <div style="height: 400px; position: relative;">
                    <canvas id="equityChart"></canvas>
                </div>
            </div>

            <div class="glass-panel">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <div class="section-title" style="margin: 0; border: none;">Net P&L</div>
                    <div>
                        <label style="margin-right: 15px; cursor: pointer; color: var(--text-secondary);">
                            <input type="radio" name="chartView" value="monthly" checked onchange="updateView()">
                            Monthly
                        </label>
                        <label style="cursor: pointer; color: var(--text-secondary);">
                            <input type="radio" name="chartView" value="daily" onchange="updateView()"> Daily
                        </label>
                    </div>
                </div>
                <div style="height: 400px; position: relative;">
                    <canvas id="monthlyChart"></canvas>
                </div>
            </div>
        </div>

        <!-- TAB 3: HISTORY -->
        <div id="tab-history" class="tab-content">
            <div class="glass-panel">
                <div class="section-title">Monthly Breakdown</div>
                <table id="monthlyTable">
                    <thead>
                        <tr>
                            <th id="periodHeader">Month</th>
                            <th>Net P&L</th>
                            <th>Cumulative P&L</th>
                            <th>Count</th>
                            <th>Win%</th>
                            <th>Run-up</th>
                            <th>Drawdown</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody"></tbody>
                </table>
            </div>

            <div class="glass-panel">
                <div class="section-title">Monthly P&L by File</div>
                <div style="overflow-x: auto;">
                    <table id="fileBreakdownTable">
                        <thead id="fileBreakdownHead"></thead>
                        <tbody id="fileBreakdownBody"></tbody>
                    </table>
                </div>
            </div>

            <div class="glass-panel">
                <div class="section-title">Trade History</div>
                <div style="max-height: 500px; overflow-y: auto;">
                    <table id="tradeListTable">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Net P&L</th>
                                <th>Run-up</th>
                                <th>Drawdown</th>
                                <th>Cumulative</th>
                                <th>File</th>
                            </tr>
                        </thead>
                        <tbody id="tradeListBody"></tbody>
                    </table>
                </div>
            </div>
            <div style="margin-top: 30px; border-left: 4px solid #cf6679; padding-left: 10px; opacity: 0.5;">
                <strong>Debug:</strong> Last 5 Parsed Trades
                <div style="font-size: 0.8em; margin-top: 5px;">
                    <table style="width: auto;">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Type</th>
                                <th>P&L</th>
                            </tr>
                        </thead>
                        <tbody id="debugTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <footer>
            Generated by Google Deepmind & Antigravity
        </footer>
    </div>

    <script>
        // --- Navigation ---
        function switchTab(tabId) {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            const btn = document.querySelector(`button[onclick="switchTab('${tabId}')"]`);
            if (btn) btn.classList.add('active');

            const content = document.getElementById('tab-' + tabId);
            if (content) content.classList.add('active');
        }

        // --- Core Logic ---
        // --- Core Logic ---
        let parsedTrades = [];
        // No global multiplier variable needed, read from DOM dynamically

        // Function to update multiplier and re-render
        function updateMultipliers() {
            const inputs = document.querySelectorAll('#fileControlsList input');
            const fileFactors = {};
            inputs.forEach(inp => {
                const val = parseFloat(inp.value);
                // Allow 0 or negative? Usually multiplier is positive. 
                // But let's just parse whatever they type. 
                // If invalid/empty, default to 1? Or 0? 1 is safer to avoid clearing data.
                fileFactors[inp.getAttribute('data-filename')] = isNaN(val) ? 1 : val;
            });

            if (parsedTrades.length > 0) {
                // Re-calculate live values from originals
                parsedTrades.forEach(t => {
                    const factor = fileFactors[t.sourceFile] !== undefined ? fileFactors[t.sourceFile] : 1;

                    if (t.originalPnl !== undefined) t.pnl = t.originalPnl * factor;
                    if (t.originalFileRunUp !== undefined) t.fileRunUp = t.originalFileRunUp * factor;
                    if (t.originalFileDrawdown !== undefined) t.fileDrawdown = t.originalFileDrawdown * factor;
                });

                // Re-render
                calculateAndRender(parsedTrades);
                // Also update the target calc if present
                calculateTargetHit();
            }
        }

        function renderFileControls(files) {
            const container = document.getElementById('fileControlsList');
            if (!container) return;
            container.innerHTML = '';

            let names = [];
            if (files[0] && files[0].name) names = files.map(f => f.name);
            else names = files;

            names.forEach(name => {
                const div = document.createElement('div');
                div.style.cssText = "border: 1px solid var(--border-color); padding: 4px 8px; border-radius: 6px; display: flex; align-items: center; gap: 8px; background: var(--bg-color); min-width: max-content;";

                div.innerHTML = `
                    <span style="font-size: 0.8em; color: var(--text-primary); font-weight:500;">${name}</span>
                    <input type="number" step="0.1" data-filename="${name}" value="1" oninput="updateMultipliers()" 
                        style="width: 60px; background: var(--surface-color); color: var(--accent-color); border: 1px solid var(--border-color); font-weight: 700; outline: none; font-size: 0.9em; padding: 2px 4px; border-radius: 4px;">
                `;
                container.appendChild(div);
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            const fileInput = document.getElementById('csvFileInput');
            renderLibraryList();

            // Enable Enter key to save
            const portfolioInput = document.getElementById('portfolioNameInput');
            if (portfolioInput) {
                portfolioInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') saveToLibrary();
                });
            }

            fileInput.addEventListener('change', async (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;

                parsedTrades = [];
                // Reset UI
                calculateAndRender([]);

                try {
                    const allTrades = await Promise.all(files.map(file => processFile(file).catch(e => {
                        console.error(`Error processing ${file.name}:`, e);
                        return [];
                    })));

                    let rawTrades = allTrades.flat();

                    // Update File List Display - NEW Dynamic Controls
                    // renderFileControls(files); 
                    // Move this AFTER dedupe/parsing? No, filenames are known here.
                    renderFileControls(files.map(f => f.name));

                    // Deduplication Logic - SAFE for Scalpers
                    if (files.length > 1) {
                        const uniqueTrades = new Map();
                        rawTrades.forEach(t => {
                            // If Date has Time -> Great. If not -> Risky.
                            let key = `${t.dateStr}_${t.pnl}`;
                            if (t.dateStr.length < 12) {
                                // Short date (YYYY-MM-DD), collision likely for scalpers.
                                // We use a content hash simulation
                                key = JSON.stringify(t);
                            }
                            if (!uniqueTrades.has(key)) uniqueTrades.set(key, t);
                        });
                        parsedTrades = Array.from(uniqueTrades.values());
                    } else {
                        // Single file: TRUST EVERY ROW. Do not dedupe.
                        parsedTrades = rawTrades;
                    }

                    if (parsedTrades.length > 0) {
                        // Extract Unique Files for Controls (Handle JSON case where sourceFile is embedded)
                        const uniqueFiles = new Set(parsedTrades.map(t => t.sourceFile).filter(Boolean));
                        // If we just uploaded files, 'files' variable has names. But for mixed or JSON, rely on trades.
                        if (uniqueFiles.size > 0) renderFileControls(Array.from(uniqueFiles));

                        calculateAndRender(parsedTrades);
                        document.getElementById('exportBtn').style.display = 'inline-block';
                    } else {
                        alert("No valid 'Exit' trades found.");
                    }
                } catch (err) {
                    console.error("Batch processing error:", err);
                }
            });
        });

        const processFile = (file) => {
            return new Promise((resolve, reject) => {
                const fileName = file.name.toLowerCase();
                const reader = new FileReader();

                if (fileName.endsWith('.csv')) {
                    reader.onload = (e) => {
                        const trades = processCSV(e.target.result);
                        trades.forEach(t => t.sourceFile = file.name); // Using file.name (original case) or fileName (lower)? User said "give the name". Original case usually better.
                        resolve(trades);
                    };
                    reader.readAsText(file);
                } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
                    reader.onload = (e) => {
                        if (typeof XLSX === 'undefined') reject(new Error("SheetJS not loaded"));
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const sheet = workbook.Sheets[workbook.SheetNames[0]];
                        const trades = processCSV(XLSX.utils.sheet_to_csv(sheet));
                        trades.forEach(t => t.sourceFile = file.name);
                        resolve(trades);
                    };
                    reader.readAsArrayBuffer(file);
                } else if (fileName.endsWith('.json')) {
                    reader.onload = (e) => {
                        const trades = JSON.parse(e.target.result);
                        if (Array.isArray(trades)) {
                            trades.forEach(t => {
                                if (!t.sourceFile) t.sourceFile = file.name;
                                // Store originals for Multiplier (if not already present in JSON)
                                if (t.originalPnl === undefined) t.originalPnl = t.pnl;
                                if (t.originalFileRunUp === undefined && t.fileRunUp !== undefined) t.originalFileRunUp = t.fileRunUp;
                                if (t.originalFileDrawdown === undefined && t.fileDrawdown !== undefined) t.originalFileDrawdown = t.fileDrawdown;
                            });
                        }
                        resolve(trades);
                    };
                    reader.readAsText(file);
                } else {
                    reject(new Error("Unsupported file"));
                }
            });
        };

        // Helper for JSON Load to render controls
        // Not straightforward because 'processFile' is per file but we render controls for all.
        // If loading JSON, it's usually single file representing portfolio.
        // Wait, if we load JSON, verify if it contains multiple sourceFiles? 
        // If it was exported from this tool, it might be an array of trades with 'sourceFile' prop.
        // We need to extract unique sourceFiles from the parsed trades to render controls.
        // We'll do this in the main event listener.

        function processCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const trades = [];
            if (lines.length < 2) return [];

            const header = lines[0].toLowerCase().split(',');
            // Column detection logic
            let typeIdx = -1, dateIdx = -1, pnlIdx = -1, runupIdx = -1, drawdownIdx = -1;

            header.forEach((col, i) => {
                const c = col.trim();
                const norm = c.replace(/[^a-z0-9]/g, ''); // runupinr, runup, maxdrawdown

                // Relaxed Type matching
                if (c.includes('type') || c.includes('side') || c.includes('direction')) typeIdx = i;

                // Safe Date matching
                if ((c.includes('exit') || c.includes('close') || c.includes('time')) && (c.includes('date') || c.includes('time'))) dateIdx = i;
                else if (c === 'date' || c === 'time' || c === 'date/time' || c === 'trade date' || c === 'date/time') {
                    if (dateIdx === -1) dateIdx = i;
                }

                // Check for Percentage
                const isPct = c.includes('%') || norm.includes('percent') || norm.includes('pct');

                // Run-up / Drawdown matching
                // Must exclude percentages to avoid capturing "Run-up %"
                if ((norm.includes('runup') || norm.includes('runupinr')) && !isPct) runupIdx = i;
                if (norm.includes('drawdown') && !isPct) drawdownIdx = i;

                // Safe PnL matching
                // MUST EXCLUDE "Cumulative", "Run-up", "Drawdown", etc.
                if (
                    (c.includes('p&l') || c.includes('profit') || (c.includes('net') && c.includes('pl')) || c.includes('gain') || c.includes('loss') || c === 'amount')
                    && !norm.includes('cumulative')
                    && !norm.includes('runup') // normalized check covers runup, run-up, etc.
                    && !norm.includes('drawdown')
                    && !c.includes('%')
                    && !c.includes('percent')
                ) {
                    pnlIdx = i;
                }
            });

            // Fallbacks
            if (typeIdx === -1) typeIdx = 1;
            if (dateIdx === -1) {
                // Try finding any date col
                header.forEach((col, i) => { if ((col.includes('date') || col.includes('time')) && dateIdx === -1) dateIdx = i; });
                if (dateIdx === -1) dateIdx = 2;
            }
            if (pnlIdx === -1) pnlIdx = 7;

            // Heuristic for Number Format (EU vs US)
            let isEuFormat = false; // Default US (1,234.56)
            let commaDecimals = 0;
            let dotDecimals = 0;

            for (let i = 1; i < Math.min(lines.length, 10); i++) {
                const cols = lines[i].split(',');
                if (cols.length > pnlIdx) {
                    const raw = cols[pnlIdx];
                    if (!raw) continue;
                    const lastComma = raw.lastIndexOf(',');
                    const lastDot = raw.lastIndexOf('.');
                    if (lastComma > lastDot && lastComma > -1) commaDecimals++;
                    if (lastDot > lastComma && lastDot > -1) dotDecimals++;
                }
            }
            if (commaDecimals > dotDecimals) isEuFormat = true;
            console.log("Detected Number Format: " + (isEuFormat ? "EU" : "US"));

            for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].split(',');
                if (cols.length <= Math.max(typeIdx, dateIdx, pnlIdx)) continue;

                const type = cols[typeIdx];
                if (!type || (!type.toLowerCase().includes('exit') && !type.toLowerCase().includes('close'))) {
                    // Filter non-exits
                    if (!type.toLowerCase().includes('exit') && !type.toLowerCase().includes('close')) continue;
                }

                const dateStr = cols[dateIdx];
                let pnlStr = cols[pnlIdx];
                if (!pnlStr) continue;

                // Helper to parse money
                const parseMoney = (str) => {
                    if (!str) return 0;
                    let val = str.trim();
                    val = val.replace(/[^0-9.,\-()]/g, '');
                    let isNeg = false;
                    if (val.startsWith('(') && val.endsWith(')')) { isNeg = true; val = val.slice(1, -1); }
                    if (isEuFormat) val = val.replace(/\./g, '').replace(/,/g, '.');
                    else val = val.replace(/,/g, '');
                    let num = parseFloat(val);
                    if (isNaN(num)) return 0;
                    return isNeg ? -Math.abs(num) : num;
                };

                const pnl = parseMoney(cols[pnlIdx]);

                // Parse Run-up / Drawdown if available
                let fileRunUp = undefined;
                let fileDrawdown = undefined;

                if (runupIdx > -1 && cols[runupIdx]) fileRunUp = parseMoney(cols[runupIdx]);
                if (drawdownIdx > -1 && cols[drawdownIdx]) fileDrawdown = parseMoney(cols[drawdownIdx]);

                // Parse Date using the robust parser
                const d = parseDate(dateStr);
                if (!d) continue;

                /* STORE ORIGINALS for Multiplier Logic */
                trades.push({
                    dateStr: dateStr,
                    month: `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`,
                    daily: `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`,
                    timestamp: d.getTime(),

                    pnl: pnl,
                    originalPnl: pnl, // Storing for scaling

                    fileRunUp: fileRunUp > 0 ? fileRunUp : undefined,
                    originalFileRunUp: fileRunUp > 0 ? fileRunUp : undefined,

                    fileDrawdown: fileDrawdown < 0 ? fileDrawdown : undefined,
                    originalFileDrawdown: fileDrawdown < 0 ? fileDrawdown : undefined,

                    displayRU: 0, // placeholders for rendering
                    displayDD: 0
                });
            }
            return trades.sort((a, b) => a.timestamp - b.timestamp);
        }
        function parseDate(str) {
            if (!str) return null;
            // distinct date and time
            const [datePart, timePart] = str.trim().split(/\s+/);

            // Try ISO first
            let d = new Date(str);
            if (!isNaN(d.getTime()) && str.includes('-') && (d.getFullYear() > 1900)) return d;

            // Custom parsing for DD-MM-YYYY etc
            if (!datePart) return null;

            const parts = datePart.split(/[-/.]/);
            if (parts.length === 3) {
                let [p1, p2, p3] = parts;
                let y, m, d_val;

                // Heuristics
                if (p1.length === 4) { y = p1; m = p2; d_val = p3; } // YYYY-MM-DD
                else if (p3.length === 4) { d_val = p1; m = p2; y = p3; } // DD-MM-YYYY
                else { d_val = p1; m = p2; y = p3; } // 2-digit year (assume DD-MM-YY)

                if (y.length === 2) y = '20' + y;

                // Month Names
                if (isNaN(parseInt(m))) {
                    const months = { jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6, jul: 7, aug: 8, sep: 9, oct: 10, nov: 11, dec: 12 };
                    m = months[m.substring(0, 3).toLowerCase()] || m;
                }

                // Reconstruct with time if available
                let isoStr = `${y}-${String(m).padStart(2, '0')}-${String(d_val).padStart(2, '0')}`;
                if (timePart) {
                    isoStr += `T${timePart}`;
                }

                d = new Date(isoStr);
                if (!isNaN(d.getTime())) return d;
            }
            return null;
        }

        function calculateAndRender(trades) {
            trades.sort((a, b) => a.timestamp - b.timestamp);

            let totalTrades = trades.length;
            let totalNetPL = trades.reduce((acc, t) => acc + t.pnl, 0);
            let wins = trades.filter(t => t.pnl > 0).length;
            let losses = trades.filter(t => t.pnl <= 0).length;
            let grossProfit = trades.filter(t => t.pnl > 0).reduce((acc, t) => acc + t.pnl, 0);
            let grossLoss = trades.filter(t => t.pnl <= 0).reduce((acc, t) => acc + Math.abs(t.pnl), 0);
            let maxSingleProfit = Math.max(0, ...trades.map(t => t.pnl));
            let maxSingleLoss = Math.min(0, ...trades.map(t => t.pnl));

            // Streaks
            let maxWinStreak = 0, currentWinStreak = 0;
            let maxWinStreakAmt = 0, currentWinStreakAmt = 0;
            let maxWinRange = '';

            let maxLoseStreak = 0, currentLoseStreak = 0;
            let maxLoseStreakAmt = 0, currentLoseStreakAmt = 0;
            let maxLoseRange = '';

            // Temp vars for range tracking
            let winStart = null, loseStart = null;

            trades.forEach(t => {
                if (t.pnl > 0) {
                    // Win
                    if (currentWinStreak === 0) winStart = t.daily;
                    currentWinStreak++;
                    currentWinStreakAmt += t.pnl;

                    if (currentWinStreak > maxWinStreak) {
                        maxWinStreak = currentWinStreak;
                        maxWinRange = `(${formatDate(winStart)} to ${formatDate(t.daily)})`;
                    }
                    if (currentWinStreakAmt > maxWinStreakAmt) maxWinStreakAmt = currentWinStreakAmt;

                    currentLoseStreak = 0; currentLoseStreakAmt = 0; loseStart = null;
                } else {
                    // Loss
                    if (currentLoseStreak === 0) loseStart = t.daily;
                    currentLoseStreak++;
                    currentLoseStreakAmt += t.pnl; // negative

                    if (currentLoseStreak > maxLoseStreak) {
                        maxLoseStreak = currentLoseStreak;
                        maxLoseRange = `(${formatDate(loseStart)} to ${formatDate(t.daily)})`;
                    }
                    if (currentLoseStreakAmt < maxLoseStreakAmt) maxLoseStreakAmt = currentLoseStreakAmt;

                    currentWinStreak = 0; currentWinStreakAmt = 0; winStart = null;
                }
            });

            // Drawdown vars
            let peak = 0;
            let maxDD = 0;
            let running = 0;
            let peakDate = trades.length > 0 ? trades[0].daily : '-';
            let peakTimestamp = trades.length > 0 ? trades[0].timestamp : 0;
            let ddRange = '';

            // Reccovery tracking
            let maxDDPeakValue = 0;
            let maxDDTroughIndex = -1;
            let maxDDTroughTimestamp = 0;

            // Run-up vars
            let maxRunUp = 0;
            let handledRunUp = false;
            let trough = 0;
            let troughDate = trades.length > 0 ? trades[0].daily : '-';
            let runUpRange = '';

            trades.forEach(t => {
                running += t.pnl;

                // Drawdown Logic
                // Drawdown Logic
                if (running > peak) {
                    peak = running;
                    peakDate = t.daily;
                    peakTimestamp = t.timestamp;
                }
                const dd = running - peak;
                if (dd < maxDD) {
                    maxDD = dd;

                    // Track for Recovery
                    maxDDPeakValue = peak;
                    maxDDTroughIndex = trades.indexOf(t); // Note: index in sorted array 'trades'
                    maxDDTroughTimestamp = t.timestamp;

                    const days = Math.floor((t.timestamp - peakTimestamp) / (1000 * 60 * 60 * 24));
                    ddRange = `<span style="color:var(--text-primary); font-weight:600;">(${formatDate(peakDate)} to ${formatDate(t.daily)})</span> <span style="margin-left:5px; color:var(--text-primary); font-weight:800;">${days} Days</span>`;
                }

                // Run-up Logic (Inverse of Drawdown)
                // Track lowest low (trough)
                if (running < trough) {
                    trough = running;
                    troughDate = t.daily;
                }
                const ru = running - trough;
                if (ru > maxRunUp) {
                    maxRunUp = ru;
                    runUpRange = `(${formatDate(troughDate)} to ${formatDate(t.daily)})`;
                }

                // Store for Table
                t.currentDD = dd;
                t.currentRU = ru;
                t.currentRU = ru;
            });

            // Calculate Recovery Days
            if (maxDDTroughIndex !== -1) {
                let recoveryFound = false;
                let recoveryDays = 0;
                let tempRunning = maxDDPeakValue + maxDD; // Running P&L at Trough

                for (let i = maxDDTroughIndex + 1; i < trades.length; i++) {
                    tempRunning += trades[i].pnl;
                    if (tempRunning >= maxDDPeakValue) {
                        // Recovered!
                        const tRecover = trades[i];
                        recoveryDays = Math.floor((tRecover.timestamp - maxDDTroughTimestamp) / (1000 * 60 * 60 * 24));
                        recoveryFound = true;
                        break;
                    }
                }

                const recText = recoveryFound
                    ? `<div style="margin-top: 2px; font-size:0.85em; color:var(--text-secondary);">Recovery: <span style="color:var(--text-primary); font-weight:800;">${recoveryDays} Days</span></div>`
                    : `<div style="margin-top: 2px; font-size:0.85em; color:var(--error-color);">Not Recovered</div>`;

                ddRange += recText;
            }
            const hasFileRunUp = trades.some(t => t.fileRunUp !== undefined);
            if (hasFileRunUp) {
                let maxSingleRunUp = 0;
                let maxSingleRunUpDate = '';

                trades.forEach(t => {
                    if (t.fileRunUp > maxSingleRunUp) {
                        maxSingleRunUp = t.fileRunUp;
                        maxSingleRunUpDate = t.daily;
                    }
                });

                if (maxSingleRunUp > 0) {
                    maxRunUp = maxSingleRunUp;

                    // Render HTML directly for the Max Run-up box to show both Max and Min
                    const elVal = document.getElementById('maxRunup');
                    const elDate = document.getElementById('maxRunupDateRange');

                    if (elVal && elDate) {
                        const fmt = (v) => new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(v);

                        // Find Min Run-up
                        let minSingleRunUp = Infinity;
                        let minSingleRunUpDate = '';
                        trades.forEach(t => {
                            if (t.fileRunUp !== undefined) {
                                if (t.fileRunUp < minSingleRunUp) {
                                    minSingleRunUp = t.fileRunUp;
                                    minSingleRunUpDate = t.daily;
                                }
                            }
                        });

                        // If no valid min found (e.g. all undefined), fallback
                        if (minSingleRunUp === Infinity) minSingleRunUp = 0;

                        // Construct HTML
                        // Using smaller font for the label/date parts to fit
                        elVal.innerHTML = `
                            <div style="display:flex; justify-content:space-between; align-items:center; font-size:0.65em; margin-bottom:4px;">
                                <span style="opacity:0.7">MAX</span>
                                <span style="color:var(--text-primary); font-weight:700">${fmt(maxSingleRunUp)}</span>
                            </div>
                            <div style="display:flex; justify-content:space-between; align-items:center; font-size:0.65em;">
                                <span style="opacity:0.7">MIN</span>
                                <span style="color:var(--text-primary); font-weight:700">${fmt(minSingleRunUp)}</span>
                            </div>
                        `;

                        // Put dates in the bottom range slot
                        elDate.innerHTML = `
                            <div style="display:flex; justify-content:space-between; margin-top: -10px; font-size:0.85em; color:var(--text-primary); font-weight:600;">
                                <span>(${formatDate(maxSingleRunUpDate)})</span>
                                <span>(${formatDate(minSingleRunUpDate)})</span>
                            </div>
                        `;

                        // Prevent standard setText from overwriting this later?
                        // The setText calls are at the end of the function (lines 920-921).
                        // I need to ensure those standard lines don't overwrite this.
                        // I should probably remove the setText calls or update the variables to be empty so setText doesn't clobber, 
                        // OR just put this logic AT THE END near the setText calls.
                        // The user wanted "same box". 

                        // If I modify this here, the `setText` at lines 920 will overwrite it.
                        // I must modify the setText calls at the bottom OR set a flag.

                        // Better strategy: Update the variables `maxRunUp` and `runUpRange` to contain the HTML string?
                        // setText uses .textContent, so HTML won't render.

                        // I will define a separate render step or variable.
                        handledRunUp = true;
                    }
                }
            }

            // OVERRIDE: Same for Drawdown (Max Single Trade Drawdown)
            const hasFileDrawdown = trades.some(t => t.fileDrawdown !== undefined);
            if (false && hasFileDrawdown) { // UNDO: Reverted to standard Drawdown
                let maxSingleDD = 0; // Want the lowest negative number
                let maxSingleDDDate = '';

                trades.forEach(t => {
                    if (t.fileDrawdown !== undefined) {
                        if (t.fileDrawdown < maxSingleDD) {
                            maxSingleDD = t.fileDrawdown;
                            maxSingleDDDate = t.daily;
                        }
                    }
                });

                if (maxSingleDD < 0) {
                    maxDD = Math.abs(maxSingleDD); // Display as positive number usually, or keep sign? 
                    // EXISTING VISUALS: Card usually shows "-$4000" in red. 
                    // However, `maxDD` variable is usually POSITIVE in calculation (dd = running - peak, which is negative...)
                    // Wait, original: `dd = running - peak` (negative). `if (dd < maxDD)` (maxDD init 0).
                    // So `maxDD` stores a NEGATIVE number.
                    maxDD = maxSingleDD;
                    ddRange = `(${formatDate(maxSingleDDDate)})`;
                }
            }



            // Display
            const fmt = (v) => new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(v);
            const fmtNum = (v) => new Intl.NumberFormat('en-IN').format(v);

            setText('totalTrades', fmtNum(totalTrades));
            setText('winningTrades', `${wins} (${totalTrades ? ((wins / totalTrades) * 100).toFixed(1) : 0}%)`);
            setText('losingTrades', `${losses} (${totalTrades ? ((losses / totalTrades) * 100).toFixed(1) : 0}%)`);
            setText('winRateDisplay', `${totalTrades ? ((wins / totalTrades) * 100).toFixed(1) : 0}%`);

            setText('totalNetProfit', fmt(totalNetPL));
            setText('grossProfit', fmt(grossProfit));
            setText('grossLoss', fmt(-grossLoss)); // Show as negative amount

            setText('avgProfit', totalTrades ? fmt(totalNetPL / totalTrades) : fmt(0));
            setText('avgWinner', wins ? fmt(grossProfit / wins) : fmt(0));
            setText('avgLoser', losses ? fmt(-grossLoss / losses) : fmt(0));

            setText('maxDrawdown', fmt(maxDD));
            const elDD = document.getElementById('maxDrawdownDateRange');
            if (elDD) elDD.innerHTML = ddRange;

            if (!handledRunUp) {
                setText('maxRunup', fmt(maxRunUp));
                setText('maxRunupDateRange', runUpRange);
            }

            setText('maxWinStreak', `${maxWinStreak} Trades`);
            setText('maxWinStreakDate', maxWinRange);
            setText('maxWinStreakAmount', fmt(maxWinStreakAmt));

            setText('maxLoseStreak', `${maxLoseStreak} Trades`);
            setText('maxLoseStreakDate', maxLoseRange);
            setText('maxLoseStreakAmount', fmt(maxLoseStreakAmt));

            // Render Charts & Tables
            renderEquityCurve(trades);
            renderTradeList(trades);
            updateView();
        }

        function formatDate(isoStr) {
            // YYYY-MM-DD -> DD-MM
            if (!isoStr) return '';
            const parts = isoStr.split('-');
            return `${parts[2]}-${parts[1]}`; // DD-MM
        }

        function setText(id, txt) {
            const el = document.getElementById(id);
            if (el) el.textContent = txt;
        }

        // --- Library Logic ---
        function saveToLibrary() {
            const name = document.getElementById('portfolioNameInput').value.trim();
            if (!name) return alert("Enter name");
            if (parsedTrades.length === 0) return alert("No data");

            const lib = JSON.parse(localStorage.getItem('portfolioLibrary') || '{}');
            lib[name] = { date: new Date().toISOString(), trades: parsedTrades };
            localStorage.setItem('portfolioLibrary', JSON.stringify(lib));
            renderLibraryList();
            document.getElementById('portfolioNameInput').value = '';
            alert("Saved!");
        }

        function renderLibraryList() {
            const list = document.getElementById('portfolioList');
            const lib = JSON.parse(localStorage.getItem('portfolioLibrary') || '{}');
            list.innerHTML = Object.keys(lib).map(name => `
                <li style="display:flex; justify-content:space-between; padding:8px; background:#2d2d2d; margin-bottom:5px; border-radius:4px;">
                    <span style="cursor:pointer; flex:1" onclick="loadLib('${name}')">${name}</span>
                    <button onclick="delLib('${name}')" style="background:none; border:none; color:#ef4444; cursor:pointer;"></button>
                </li>
            `).join('');
        }

        window.loadLib = (name) => {
            const lib = JSON.parse(localStorage.getItem('portfolioLibrary') || '{}');
            if (lib[name]) {
                parsedTrades = lib[name].trades;
                // Update Title to show open portfolio
                document.getElementById('reportTitle').textContent = `FiFto Backtest report - ${name}`;
                calculateAndRender(parsedTrades);
            }
        };

        window.delLib = (name) => {
            const lib = JSON.parse(localStorage.getItem('portfolioLibrary') || '{}');
            delete lib[name];
            localStorage.setItem('portfolioLibrary', JSON.stringify(lib));
            renderLibraryList();
        };

        function exportPortfolio() {
            const dataStr = JSON.stringify(parsedTrades, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `portfolio_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // --- Chart/Table Logic ---
        let equityChart = null;
        function renderEquityCurve(trades) {
            const ctx = document.getElementById('equityChart').getContext('2d');
            if (equityChart) equityChart.destroy();

            let run = 0;
            const data = trades.map(t => { run += t.pnl; return run; });
            const labels = trades.map(t => t.dateStr);

            equityChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [{
                        label: 'Equity',
                        data,
                        borderColor: '#38bdf8',
                        backgroundColor: 'rgba(56, 189, 248, 0.1)',
                        fill: true,
                        tension: 0.1,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { display: false },
                        y: { grid: { color: '#334155' }, ticks: { color: '#94a3b8' } }
                    }
                }
            });
        }

        let barChart = null;
        function updateView() {
            if (!parsedTrades.length) return;
            const mode = document.querySelector('input[name="chartView"]:checked').value;

            // Aggregate
            const map = {};
            // We need order for DD/RU, so process sorted trades.
            // Trades are already sorted by time in calculateAndRender.
            parsedTrades.forEach(t => {
                const k = mode === 'monthly' ? t.month : t.daily;
                if (!map[k]) {
                    map[k] = {
                        label: k,
                        pnl: 0,
                        count: 0,
                        wins: 0,
                        // Per-period DD/RU tracking
                        running: 0,
                        peak: 0,
                        maxDD: 0,
                        trough: 0,
                        maxRunUp: 0
                    };
                }
                const m = map[k];
                m.pnl += t.pnl;
                m.count++;
                if (t.pnl > 0) m.wins++;

                // Calc DD/RU within this period
                m.running += t.pnl;

                // DD (Local)
                if (m.running > m.peak) m.peak = m.running;
                const dd = m.running - m.peak;
                if (dd < m.maxDD) m.maxDD = dd;

                // RU (Local)
                if (m.running < m.trough) m.trough = m.running;
                const ru = m.running - m.trough;
                if (ru > m.maxRunUp) m.maxRunUp = ru;

                // Track File Data Separately
                if (t.fileRunUp !== undefined) {
                    if (m.fileRunUpTotal === undefined) m.fileRunUpTotal = 0;
                    m.fileRunUpTotal += t.fileRunUp;
                }
                if (t.fileDrawdown !== undefined) {
                    if (m.fileDrawdownMax === undefined) m.fileDrawdownMax = 0; // usually negative/zero
                    if (t.fileDrawdown < m.fileDrawdownMax) m.fileDrawdownMax = t.fileDrawdown;
                }
            });

            const data = Object.keys(map).sort().map(k => {
                const m = map[k];
                // Apply Overrides
                if (m.fileRunUpTotal !== undefined) m.maxRunUp = m.fileRunUpTotal;
                if (m.fileDrawdownMax !== undefined) m.maxDD = m.fileDrawdownMax;
                return m;
            });

            renderTable(data);
            renderBarChart(data);
            renderFileBreakdown(parsedTrades); // New dynamic table

            document.getElementById('periodHeader').textContent = mode === 'monthly' ? 'Month' : 'Date';
        }

        function renderFileBreakdown(trades) {
            // 1. Identify all unique files and months
            const files = new Set();
            const months = new Set();
            const pivot = {}; // { 'YYYY-MM': { total: 0, 'file1': 0, ... } }

            trades.forEach(t => {
                const fName = t.sourceFile || 'Unknown';
                files.add(fName);

                // Always group by Month for this table, regardless of chart view
                const m = t.month || 'Unknown';
                months.add(m);

                if (!pivot[m]) pivot[m] = { total: 0 };
                if (!pivot[m][fName]) pivot[m][fName] = 0;

                pivot[m][fName] += t.pnl;
                pivot[m].total += t.pnl;
            });

            const sortedMonths = Array.from(months).sort(); // Oldest first? or Newest? 
            // Usually Monthly reports are chronologically sorted. "sort()" does ISO string => Oldest First.

            const sortedFiles = Array.from(files).sort();

            // 2. Render Header
            const thead = document.getElementById('fileBreakdownHead');
            const tbody = document.getElementById('fileBreakdownBody');
            if (!thead || !tbody) return;

            // Header Row
            let headerHTML = `<tr><th>Month</th><th>Total P&L</th>`;
            sortedFiles.forEach(f => {
                headerHTML += `<th>${f}</th>`;
            });
            headerHTML += `</tr>`;
            thead.innerHTML = headerHTML;

            // 3. Render Body
            const fmt = (v) => new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(v);

            tbody.innerHTML = sortedMonths.map(m => {
                if (m === 'Unknown') return ''; // Skip invalid dates
                const rowData = pivot[m];
                const totalClass = rowData.total >= 0 ? 'text-green' : 'text-red';

                let rowHTML = `<tr>
                    <td>${m}</td>
                    <td class="${totalClass}" style="font-weight:bold">${fmt(rowData.total)}</td>`;

                sortedFiles.forEach(f => {
                    const val = rowData[f] || 0;
                    const cls = val >= 0 ? 'text-green' : 'text-red';
                    // If val is 0 and not present, maybe show '-'? 
                    // Check if file existed in that month? Complex. Just show 0 or val.
                    rowHTML += `<td class="${cls}">${fmt(val)}</td>`;
                });

                rowHTML += `</tr>`;
                return rowHTML;
            }).join('');
        }

        function renderBarChart(data) {
            const ctx = document.getElementById('monthlyChart').getContext('2d');
            if (barChart) barChart.destroy();

            barChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(d => d.label),
                    datasets: [{
                        data: data.map(d => d.pnl),
                        backgroundColor: data.map(d => d.pnl >= 0 ? '#10b981' : '#ef4444'),
                        borderRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { ticks: { color: '#94a3b8' }, grid: { display: false } },
                        y: { grid: { color: '#334155' }, ticks: { color: '#94a3b8' } }
                    }
                }
            });
        }

        function renderTable(data) {
            const tbody = document.getElementById('tableBody');
            let cum = 0;
            const fmt = (v) => new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(v);

            tbody.innerHTML = data.map(row => {
                cum += row.pnl;
                const winRate = ((row.wins / row.count) * 100).toFixed(1) + '%';
                // Add click handler for filtering
                return `<tr class="clickable-row" onclick="filterHistory('${row.label}')" title="Click to view trades for ${row.label}">
                    <td>${row.label}</td>
                    <td class="${row.pnl >= 0 ? 'text-green' : 'text-red'}">${fmt(row.pnl)}</td>
                    <td class="${cum >= 0 ? 'text-green' : 'text-red'}">${fmt(cum)}</td>
                    <td>${row.count}</td>
                    <td>${winRate}</td>
                    <td class="text-green">${fmt(row.maxRunUp)}</td>
                    <td class="text-red">${fmt(row.maxDD)}</td>
                </tr>`;
            }).join('');
        }

        function renderTradeList(trades) {
            const tbody = document.getElementById('tradeListBody');
            // We need to loop manually or map correctly. 
            // Note: The 'cum' variable in previous code was just summing P&L linearly.
            // But we actually calculated 'cum' inside calculateAndRender properly too or we can just reconstruct.
            // Actually, calculateAndRender didn't store 'cum' on 't'. 
            // Let's recalculate accurately or use t.currentDD / t.currentRU from calculateAndRender.

            const fmt = (v) => new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(v);
            let runningPnl = 0;
            let peak = 0;
            let trough = 0;

            const rows = trades.map(t => {
                runningPnl += t.pnl; // Re-calculate cumulative for display

                // Calc Local DD/RU for valid table view consistency
                if (runningPnl > peak) peak = runningPnl;
                const dd = runningPnl - peak;

                if (runningPnl < trough) trough = runningPnl;
                const ru = runningPnl - trough;

                // Priority: File Data > Local Calculation
                const displayDD = (t.fileDrawdown !== undefined) ? t.fileDrawdown : dd;
                const displayRU = (t.fileRunUp !== undefined) ? t.fileRunUp : ru;

                return { ...t, cum: runningPnl, displayDD, displayRU };
            });

            // We want to show Newest First usually? Or Oldest First?
            // Existing code was Oldest first. Let's stick to that or Reverse as preferred.
            // User didn't specify, but history usually implies order.
            // Let's keep original order (Oldest -> Newest) as per chart.

            tbody.innerHTML = rows.map(t => {
                return `<tr>
                    <td>${t.dateStr}</td>
                    <td class="${t.pnl >= 0 ? 'text-green' : 'text-red'}">${fmt(t.pnl)}</td>
                    <td class="text-green">${fmt(t.displayRU)}</td>
                    <td class="text-red">${fmt(t.displayDD)}</td>
                    <td class="${t.cum >= 0 ? 'text-green' : 'text-red'}">${fmt(t.cum)}</td>
                    <td style="font-size:0.8em; opacity:0.7;">${t.sourceFile || '-'}</td>
                </tr>`;
            }).join('');

            document.getElementById('debugTableBody').innerHTML = trades.slice(-5).map(t => `
                <tr><td>${t.dateStr}</td><td>Exit</td><td>${t.pnl}</td></tr>
            `).join('');
        }

        // Filter Logic
        let currentFilter = null;
        function filterHistory(label) {
            // Determine if label is Month (YYYY-MM) or Date (YYYY-MM-DD) based on mode
            const mode = document.querySelector('input[name="chartView"]:checked').value;

            // Toggle Filter
            if (currentFilter === label) {
                currentFilter = null;
                renderTradeList(parsedTrades); // Reset
                // Optional: visual feedback reset
            } else {
                currentFilter = label;
                const filtered = parsedTrades.filter(t => {
                    return mode === 'monthly' ? t.month === label : t.daily === label;
                });
                renderTradeList(filtered);
                // Auto-scroll to History Table
                const tableEl = document.getElementById('tradeListTable');
                if (tableEl) tableEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }

            // Re-render monthly table to show selection? 
            // Maybe just highlight row. For now, simple standard re-render might be overkill or lose selection state if we don't track it.
            // Let's just highlight the row manually or via CSS class if we re-rendered.
            // But renderTable is called by updateView.
            // Let's simple alert or scroll? No, just filter.
        }
        function calculateTargetHit() {
            const val = document.getElementById('runupTargetInput').value;
            const resEl = document.getElementById('runupTargetResult');
            const pctEl = document.getElementById('runupTargetPercent');

            if (!val || !parsedTrades.length) {
                resEl.textContent = '-- / --';
                pctEl.textContent = '--%';
                return;
            }

            const target = parseFloat(val);
            if (isNaN(target)) return;

            // Count trades that reached target run-up
            // Priority: fileRunUp > calculated 'ru' (which isn't stored on 't' in parsedTrades usually, but we can re-calc or use what we have)
            // Wait, 'parsedTrades' only has fileRunUp if from file. Local 'ru' is calculated in updateView/calculateAndRender but not persisted to parsedTrades array permanently unless we modify objects.
            // In calculateAndRender, we iterate but don't save 'ru' to the object set efficiently for external access? 
            // Actually, we can just re-calculate local runup if needed: (max profit during trade). 
            // EXCEPT: We don't have intra-trade data locally. We only have 'pnl'.
            // For local data: Max Run Up = Max(0, Pnl) ? No, that's simplified.
            // If we don't have MFE (Max Favorable Excursion), we can't know if a losing trade was up +500 at some point.
            // SO: If fileRunUp is missing, we can arguably only use 'pnl' if > 0 as a "at least reached this" lower bound? 
            // Or just rely on fileRunUp.
            // Let's rely on fileRunUp if present. If not, use Math.max(0, t.pnl).

            const count = parsedTrades.filter(t => {
                let r = t.fileRunUp;
                if (r === undefined) {
                    // Fallback: If trade ended positive, it at least reached that. 
                    // If negative, we don't know (could have been green). 
                    // Assume 0 for neg? Or Pnl for pos.
                    r = t.pnl > 0 ? t.pnl : 0;
                }
                return r >= target;
            }).length;

            const total = parsedTrades.length;
            const pct = ((count / total) * 100).toFixed(1);

            resEl.textContent = `${count} / ${total} Trades`;
            pctEl.textContent = `${pct}% Reached Target`;
        }
    </script>
</body>

</html>