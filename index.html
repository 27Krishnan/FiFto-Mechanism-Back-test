<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monthly Trading Report</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <style>
        :root {
            /* Professional Premium Dark (Slate Theme) */
            --bg-color: #0f172a;
            --surface-color: #1e293b;
            --surface-hover: #334155;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --accent-color: #38bdf8;
            --success-color: #10b981;
            --error-color: #ef4444;
            --border-color: #334155;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --transition: all 0.2s ease-in-out;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            margin: 0;
            padding: 20px;
            font-size: 14px;
            min-height: 100vh;
            font-variant-numeric: tabular-nums;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: block;
            min-height: 80vh;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        h1 {
            color: var(--text-primary);
            margin: 0;
            font-weight: 800;
            font-size: 1.5rem;
            letter-spacing: -0.025em;
            text-transform: uppercase;
        }

        .controls {
            padding: 10px;
            background-color: var(--surface-color);
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid var(--border-color);
        }

        /* Tabs */
        .tab-nav {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .tab-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1rem;
            font-weight: 500;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 20px;
            transition: var(--transition);
        }

        .tab-btn:hover {
            color: var(--text-primary);
            background: var(--surface-hover);
        }

        .tab-btn.active {
            color: #000;
            background: var(--accent-color);
            font-weight: 600;
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.3);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Stats Dashboard */
        .stats-dashboard {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 15px;
            margin-bottom: 30px;
        }

        .stats-card {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .stats-card:hover {
            transform: translateY(-3px);
            border-color: var(--accent-color);
        }

        .stats-card-title {
            color: var(--text-secondary);
            font-size: 0.85em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 10px;
        }

        .stats-card-value {
            color: var(--text-primary);
            font-size: 2em;
            font-weight: 700;
            margin-bottom: 12px;
        }

        .stats-card-sub {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-top: auto;
            display: flex;
            justify-content: flex-start;
            align-items: center;
        }

        /* Common Components */
        .glass-panel {
            background: var(--surface-color);
            border-radius: 12px;
            padding: 24px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .section-title {
            color: var(--text-primary);
            font-weight: 700;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            width: 100%;
        }

        th,
        td {
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            color: var(--text-secondary);
            font-weight: 600;
            background-color: rgba(0, 0, 0, 0.2);
            text-transform: uppercase;
            font-size: 0.75em;
        }

        tr:hover {
            background-color: var(--surface-hover);
        }

        .text-green {
            color: var(--success-color);
        }

        .text-red {
            color: var(--error-color);
        }

        .primary-btn {
            background: var(--success-color);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 700;
            cursor: pointer;
            transition: var(--transition);
        }

        .primary-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        input[type="text"] {
            background: #0f172a;
            border: 1px solid var(--border-color);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            outline: none;
        }

        input[type="text"]:focus {
            border-color: var(--accent-color);
        }

        footer {
            text-align: center;
            color: var(--text-secondary);
            margin-top: 40px;
            font-size: 0.8em;
        }

        .clickable-row {
            cursor: pointer;
            transition: background 0.2s;
        }

        .clickable-row:hover {
            background-color: var(--surface-hover);
        }

        /* Premium File Chip Styles */
        .file-chip {
            background: rgba(30, 41, 59, 0.7);
            border: 1px solid rgba(148, 163, 184, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 6px 12px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 0.85em;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .file-chip::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.03), transparent);
            transform: translateX(-100%);
            transition: transform 0.5s;
        }

        .file-chip:hover::before {
            transform: translateX(100%);
        }

        .file-chip:hover {
            border-color: rgba(56, 189, 248, 0.4);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.15), 0 0 0 1px rgba(56, 189, 248, 0.1);
            transform: translateY(-1px);
        }

        .file-chip.hidden {
            background: rgba(15, 23, 42, 0.6);
            opacity: 0.5;
            border-color: transparent;
            box-shadow: none;
            filter: grayscale(1);
        }

        .file-chip.hidden:hover {
            opacity: 0.8;
            border-color: rgba(148, 163, 184, 0.2);
            filter: grayscale(0.5);
        }

        .chip-name {
            font-weight: 600;
            color: var(--text-primary);
            max-width: 140px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            letter-spacing: 0.01em;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .chip-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            padding-left: 10px;
            margin-left: 2px;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chip-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            display: flex;
            transition: all 0.2s;
            border-radius: 4px;
        }

        .chip-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .chip-btn.show {
            color: #38bdf8;
        }

        .chip-btn.hide {
            color: #64748b;
        }

        .chip-btn.delete {
            color: #ef4444;
            opacity: 0.7;
        }

        .chip-btn.delete:hover {
            opacity: 1;
            background: rgba(239, 68, 68, 0.15);
        }

        .chip-input-group {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 8px;
            border-radius: 4px;
            margin-left: 4px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: border-color 0.2s;
        }

        .chip-input-group:focus-within {
            border-color: rgba(56, 189, 248, 0.3);
        }

        .chip-input {
            width: 40px;
            background: transparent;
            border: none;
            color: #38bdf8;
            font-weight: 700;
            outline: none;
            font-size: 0.95em;
            text-align: right;
            font-family: 'Inter', monospace;

        }

        /* Chrome, Safari, Edge, Opera */
        .chip-input::-webkit-outer-spin-button,
        .chip-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Firefox */
        .chip-input[type=number] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        .spinner-btns {
            display: flex;
            flex-direction: column;
            margin-left: 2px;
        }

        .spin-btn {
            background: rgba(255, 255, 255, 0.05);
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0 4px;
            font-size: 0.6em;
            /* Tiny arrows */
            height: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .spin-btn:hover {
            background: rgba(56, 189, 248, 0.2);
            color: var(--accent-color);
        }

        .spin-btn.up {
            border-radius: 2px 2px 0 0;
            margin-bottom: 1px;
        }

        .spin-btn.down {
            border-radius: 0 0 2px 2px;
        }
    </style>
</head>

<body>

    <div class="container">
        <header>
            <h1 id="reportTitle">FiFto Backtest report</h1>
            <div class="controls" style="border:none; background:transparent; padding:0;">
                <button class="primary-btn" onclick="document.getElementById('csvFileInput').click()"
                    style="display:flex; align-items:center; gap:8px;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                        <polyline points="17 8 12 3 7 8" />
                        <line x1="12" y1="3" x2="12" y2="15" />
                    </svg>
                    Upload New Report
                </button>
                <input type="file" id="csvFileInput" multiple style="display:none" accept=".csv, .xlsx, .xls, .json">
                <input type="file" id="mergeFileInput" multiple style="display:none" accept=".csv, .xlsx, .xls, .json">
                <button id="exportBtn" onclick="exportPortfolio()" class="primary-btn"
                    style="display: none; background: #334155; color: #f8fafc;">Export JSON</button>
            </div>
        </header>

        <!-- Active Files Panel (New Design) -->
        <div id="activeFilesPanel"
            style="background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 12px; padding: 15px; margin-bottom: 25px; display:none;">
            <div
                style="font-size: 0.75em; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-secondary); margin-bottom: 10px; font-weight: 600;">
                Active Data Sources & Multipliers
            </div>
            <div id="fileControlsList" style="display: flex; flex-wrap: wrap; gap: 10px;">
                <!-- items injected here -->
            </div>

            <!-- Date Range Filter -->
            <div
                style="background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 12px; padding: 15px; margin-bottom: 25px; display:flex; gap:20px; align-items:center;">
                <div
                    style="font-size: 0.85em; text-transform: uppercase; letter-spacing: 0.05em; color: #e2e8f0; font-weight: 700;">
                    Date Filter
                </div>
                <div style="display:flex; align-items:center; gap:10px;">
                    <label style="font-size:0.95em; color:#cbd5e1; font-weight:500;">Start:</label>
                    <input type="date" id="startDateInput" onchange="applyFilters()"
                        style="background:#1e293b; border:1px solid #475569; color:#f8fafc; padding:6px 10px; border-radius:6px; outline:none; font-family:inherit;">
                </div>
                <div style="display:flex; align-items:center; gap:10px;">
                    <label style="font-size:0.95em; color:#cbd5e1; font-weight:500;">End:</label>
                    <input type="date" id="endDateInput" onchange="applyFilters()"
                        style="background:#1e293b; border:1px solid #475569; color:#f8fafc; padding:6px 10px; border-radius:6px; outline:none; font-family:inherit;">
                </div>
                <button onclick="clearDateFilters()"
                    style="background:#334155; border:1px solid #475569; color:#f8fafc; padding:6px 16px; border-radius:6px; cursor:pointer; font-size:0.85em; font-weight:600; transition:all 0.2s;">Clear</button>
            </div>
        </div>

        <!-- Tab Navigation -->
        <nav class="tab-nav">
            <button class="tab-btn active" onclick="switchTab('dashboard')">Dashboard</button>
            <button class="tab-btn" onclick="switchTab('charts')">Analysis</button>
            <!-- <button class="tab-btn" onclick="switchTab('time-analysis')">Time Analysis</button> -->
            <button class="tab-btn" onclick="switchTab('streaks')">Streak Analysis</button>
            <button class="tab-btn" onclick="switchTab('history')">History</button>
        </nav>

        <!-- TAB 1: DASHBOARD -->
        <div id="tab-dashboard" class="tab-content active">
            <div class="stats-dashboard">
                <!-- Card 1: Performance -->
                <div class="stats-card" onclick="goToHistory('daily')" style="cursor: pointer;">
                    <div class="stats-card-title">Performance</div>
                    <div class="stats-card-value" id="winRateDisplay">--%</div>
                    <div class="stats-card-sub">
                        <span>Wins: <span id="winningTrades" class="text-green">0</span></span>
                    </div>
                    <div class="stats-card-sub" style="margin-top: 5px;">
                        <span>Losses: <span id="losingTrades" class="text-red">0</span></span>
                    </div>
                    <div class="stats-card-sub" style="margin-top: 5px; font-size: 0.8em; opacity: 0.7;">
                        Total Trades: <span id="totalTrades">--</span>
                    </div>
                </div>

                <!-- Card 2: Net Profit -->
                <div class="stats-card">
                    <div class="stats-card-title">Total Net Profit</div>
                    <div class="stats-card-value" id="totalNetProfit">--</div>
                    <div class="stats-card-sub">
                        <span>Gross P: <span id="grossProfit" class="text-green">--</span></span>
                    </div>
                    <div class="stats-card-sub" style="margin-top: 5px;">
                        <span>Gross L: <span id="grossLoss" class="text-red">--</span></span>
                    </div>
                </div>

                <!-- Card: Yearly Overview (New) -->
                <div class="stats-card" onclick="goToHistory('monthly')" style="cursor: pointer;">
                    <div class="stats-card-title">Yearly Overview</div>
                    <div class="stats-card-value" style="font-size:1.1em; display:flex; flex-direction:column; gap:4px;"
                        id="yearlyStatsList">
                        <!-- Populated by JS -->
                    </div>
                </div>

                <!-- Card 3: Averages -->
                <div class="stats-card">
                    <div class="stats-card-title">Average Trade</div>
                    <div class="stats-card-value" id="avgProfit">--</div>
                    <div class="stats-card-sub">
                        <span>Avg Win: <span id="avgWinner" class="text-green">--</span></span>
                    </div>
                    <div class="stats-card-sub" style="margin-top: 5px;">
                        <span>Avg Loss: <span id="avgLoser" class="text-red">--</span></span>
                    </div>
                </div>

                <!-- Card: Risk Reward Ratio (New) -->
                <div class="stats-card">
                    <div class="stats-card-title">Risk : Reward</div>
                    <div class="stats-card-value" id="rrRatio">--</div>
                    <div class="stats-card-sub">
                        <span>Avg Win: <span id="rrAvgWin" class="text-green">--</span></span>
                    </div>
                    <div class="stats-card-sub" style="margin-top: 5px;">
                        <span>Avg Loss: <span id="rrAvgLoss" class="text-red">--</span></span>
                    </div>
                </div>

                <!-- Card 4: Drawdown -->
                <div class="stats-card">
                    <div class="stats-card-title">Max Drawdown</div>
                    <div class="stats-card-value text-red" id="maxDrawdown">--</div>
                    <div class="stats-card-sub" style="flex-direction: column; align-items: flex-start;">
                        <span id="maxDrawdownDateRange" style="font-size: 0.8em; opacity: 0.7;"></span>
                    </div>
                </div>

                <!-- Card: Max Run-up (New) -->
                <div class="stats-card">
                    <div class="stats-card-title">Max Run-up</div>
                    <div class="stats-card-value text-green" id="maxRunup">--</div>
                    <div class="stats-card-sub" style="flex-direction: column; align-items: flex-start;">
                        <span id="maxRunupDateRange" style="font-size: 0.8em; opacity: 0.7;"></span>
                    </div>
                </div>

                <!-- Card 5: Streaks -->
                <div class="stats-card" onclick="goToStreak('win')" style="cursor: pointer;">
                    <div class="stats-card-title">Best Streak</div>
                    <div class="stats-card-value text-green" id="maxWinStreak" style="font-size: 1.5em;">--</div>
                    <div class="stats-card-sub">
                        <span id="maxWinStreakDate" style="font-size: 0.9em; opacity: 0.7;"></span>
                    </div>
                    <div class="stats-card-sub">
                        <span>Amount: <span id="maxWinStreakAmount" class="text-green"
                                style="font-weight: 700;">--</span></span>
                    </div>
                </div>

                <!-- Card 6: Worst Streak -->
                <div class="stats-card" onclick="goToStreak('loss')" style="cursor: pointer;">
                    <div class="stats-card-title">Worst Streak</div>
                    <div class="stats-card-value text-red" id="maxLoseStreak" style="font-size: 1.5em;">--</div>
                    <div class="stats-card-sub">
                        <span id="maxLoseStreakDate" style="font-size: 0.9em; opacity: 0.7;"></span>
                    </div>
                    <div class="stats-card-sub">
                        <span>Amount: <span id="maxLoseStreakAmount" class="text-red"
                                style="font-weight: 700;">--</span></span>
                    </div>
                </div>

                <!-- Card 7: Run-up Target Calculator -->
                <div class="stats-card">
                    <div class="stats-card-title">Run-up Target</div>
                    <div style="margin-bottom: 10px;">
                        <input type="number" id="runupTargetInput" placeholder="Enter INR Target (e.g. 1000)"
                            style="width: 100%; box-sizing: border-box; background: var(--bg-color); border: 1px solid var(--border-color); padding: 8px; border-radius: 6px; color: var(--text-primary);"
                            oninput="calculateTargetHit()">
                    </div>
                    <div class="stats-card-value" id="runupTargetResult" style="font-size: 1.2em;">-- / --</div>
                    <div class="stats-card-sub" id="runupTargetPercent" style="color: var(--accent-color);">
                        --%
                    </div>
                </div>

                <!-- Card 8: Biggest Wins -->
                <div class="stats-card">
                    <div class="stats-card-title">Biggest Wins</div>
                    <div class="stats-card-value text-green" id="maxSingleProfitDisplay" style="font-size: 1.5em;">--
                    </div>
                    <div class="stats-card-sub" style="flex-direction: column; align-items: flex-start; gap: 4px;"
                        id="top3WinsList">
                        <!-- Injected via JS -->
                    </div>
                </div>

                <!-- Card 9: Biggest Losses -->
                <div class="stats-card">
                    <div class="stats-card-title">Biggest Losses</div>
                    <div class="stats-card-value text-red" id="maxSingleLossDisplay" style="font-size: 1.5em;">--</div>
                    <div class="stats-card-sub" style="flex-direction: column; align-items: flex-start; gap: 4px;"
                        id="top3LossesList">
                        <!-- Injected via JS -->
                    </div>
                </div>
            </div>

            <!-- Utilities -->
            <section id="utilities" style="border-top: 1px solid var(--border-color); padding-top: 20px;">
                <div class="glass-panel" style="max-width: 600px; margin: 0 auto;">
                    <div class="section-title">Portfolio Library</div>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <input type="text" id="portfolioNameInput" placeholder="Save current portfolio as..."
                            style="flex: 1;">
                        <button onclick="saveToLibrary()" class="primary-btn">Save</button>
                    </div>
                    <ul id="portfolioList"
                        style="list-style: none; padding: 0; margin: 0; max-height: 200px; overflow-y: auto;">
                        <!-- Items injected here -->
                    </ul>
                </div>
            </section>
        </div>

        <!-- TAB 2: ANALYSIS -->
        <div id="tab-charts" class="tab-content">
            <div class="glass-panel">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                    <div class="section-title" style="margin:0;">Equity Curve</div>
                    <div
                        style="display:flex; gap:10px; background:var(--bg-color); padding:4px; border-radius:6px; border:1px solid var(--border-color);">
                        <label style="cursor:pointer; display:flex; align-items:center; gap:5px; padding:2px 6px;">
                            <input type="radio" name="equityView" value="daily" checked
                                onchange="calculateAndRender(parsedTrades)">
                            <span style="font-size:0.85em; color:var(--text-secondary);">Daily</span>
                        </label>
                        <label style="cursor:pointer; display:flex; align-items:center; gap:5px; padding:2px 6px;">
                            <input type="radio" name="equityView" value="monthly"
                                onchange="calculateAndRender(parsedTrades)">
                            <span style="font-size:0.85em; color:var(--text-secondary);">Monthly</span>
                        </label>
                    </div>
                </div>
                <div style="height: 400px; position: relative;">
                    <canvas id="equityChart"></canvas>
                </div>
            </div>

            <div class="glass-panel">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <div class="section-title" style="margin: 0; border: none;">Net P&L</div>
                    <div>
                        <label style="margin-right: 15px; cursor: pointer; color: var(--text-secondary);">
                            <input type="radio" name="chartView" value="monthly" checked onchange="updateView()">
                            Monthly
                        </label>
                        <label style="cursor: pointer; color: var(--text-secondary);">
                            <input type="radio" name="chartView" value="daily" onchange="updateView()"> Daily
                        </label>
                    </div>
                </div>
                <div style="height: 400px; position: relative;">
                    <canvas id="monthlyChart"></canvas>
                </div>
            </div>

            <!-- Pie Charts Section -->
            <div
                style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom:20px;">
                <div class="glass-panel">
                    <div class="section-title">Win / Loss Ratio</div>
                    <div style="height: 300px; position: relative;">
                        <canvas id="pieWinLoss"></canvas>
                    </div>
                </div>
                <div class="glass-panel">
                    <div class="section-title">Trade Distribution by File</div>
                    <div style="height: 300px; position: relative;">
                        <canvas id="pieFileDist"></canvas>
                    </div>
                </div>
            </div>
        </div>
        <!-- TAB: TIME ANALYSIS -->
        <div id="tab-time-analysis" class="tab-content">
            <div class="glass-panel">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                    <div class="section-title" style="margin:0;">Performance by Time of Day</div>
                    <div
                        style="display:flex; gap:10px; background:var(--bg-color); padding:4px; border-radius:6px; border:1px solid var(--border-color);">
                        <label style="cursor:pointer; display:flex; align-items:center; gap:5px; padding:2px 6px;">
                            <input type="radio" name="timeGrouping" value="15" checked
                                onchange="renderTimeAnalysis(parsedTrades)">
                            <span style="font-size:0.85em; color:var(--text-secondary);">15 Min</span>
                        </label>
                        <label style="cursor:pointer; display:flex; align-items:center; gap:5px; padding:2px 6px;">
                            <input type="radio" name="timeGrouping" value="30"
                                onchange="renderTimeAnalysis(parsedTrades)">
                            <span style="font-size:0.85em; color:var(--text-secondary);">30 Min</span>
                        </label>
                        <label style="cursor:pointer; display:flex; align-items:center; gap:5px; padding:2px 6px;">
                            <input type="radio" name="timeGrouping" value="60"
                                onchange="renderTimeAnalysis(parsedTrades)">
                            <span style="font-size:0.85em; color:var(--text-secondary);">1 Hour</span>
                        </label>
                    </div>
                </div>

                <div style="height: 350px; position: relative; margin-bottom:30px;">
                    <canvas id="timeChart"></canvas>
                </div>

                <div style="overflow-x: auto;">
                    <table id="timeTable" style="width:100%;">
                        <thead>
                            <tr>
                                <th>Time Slot</th>
                                <th>Trades</th>
                                <th>Wins</th>
                                <th>Losses</th>
                                <th>Win %</th>
                                <th>Net P&L</th>
                            </tr>
                        </thead>
                        <tbody id="timeTableBody">
                            <!-- Injected JS -->
                        </tbody>
                    </table>
                </div>

                <!-- Manual Time Filter Section -->
                <div style="margin-top:30px; border-top:1px solid var(--border-color); padding-top:20px;">
                    <div class="subtitle" style="margin-bottom:10px;">Filter Trades by Time</div>

                    <!-- NEW TABS -->
                    <div
                        style="display:flex; gap:10px; margin-bottom:15px; border-bottom:1px solid var(--border-color);">
                        <button id="btn-analysis-entry" class="tab-btn active"
                            onclick="switchAnalysisMode('entry')">Entry Analysis</button>
                        <button id="btn-analysis-exit" class="tab-btn" onclick="switchAnalysisMode('exit')">Exit
                            Analysis</button>
                    </div>

                    <div style="display:flex; gap:15px; flex-wrap:wrap; align-items:flex-end; margin-bottom:20px;">
                        <div style="display:flex; align-items:center; gap:8px;">
                            <label style="color:var(--text-secondary); font-size:0.9em;">From:</label>
                            <input type="time" id="timeAnalysisStart"
                                style="background:var(--bg-color); border:1px solid var(--border-color); color:var(--text-primary); padding:4px 8px; border-radius:6px; outline:none;">
                        </div>
                        <div style="display:flex; align-items:center; gap:8px;">
                            <label style="color:var(--text-secondary); font-size:0.9em;">To:</label>
                            <input type="time" id="timeAnalysisEnd"
                                style="background:var(--bg-color); border:1px solid var(--border-color); color:var(--text-primary); padding:4px 8px; border-radius:6px; outline:none;">
                        </div>
                        <button onclick="filterTimeAnalysisTrades()" class="primary-btn"
                            style="padding:4px 12px; font-size:0.9em;">Show Trades</button>
                    </div>

                    <div style="overflow-x: auto;">
                        <table id="timeTradesTable" style="width:100%; display:none;">
                            <thead>
                                <tr>
                                    <th>Date</th>
                                    <th>Time</th>
                                    <th>Signal</th>
                                    <th>Price</th>
                                    <th>Type</th>
                                    <th>P&L</th>
                                    <th>File</th>
                                </tr>
                            </thead>
                            <tbody id="timeTradesBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB 5: STREAK ANALYSIS (New) -->
        <div id="tab-streaks" class="tab-content">
            <h2 style="margin-top:0;">Streak Analysis</h2>
            <div style="display:grid; grid-template-columns: 1fr; gap:20px;">
                <!-- Table: Winning Streaks -->
                <div id="box-win-streaks" class="stats-card"
                    style="padding:0; overflow:hidden; justify-content: flex-start;">
                    <div style="padding:15px; background:#1e293b; border-bottom:1px solid #334155;">
                        <div class="stats-card-title">Winning Streaks Distribution</div>
                    </div>
                    <div style="overflow-x:auto;">
                        <table style="width:100%; border-collapse:collapse;">
                            <thead>
                                <tr style="background:#0f172a; color:#94a3b8; font-size:0.85em; text-align:left;">
                                    <th style="padding:10px 15px;">Streak Length</th>
                                    <th style="padding:10px 15px;">Count (Frequency)</th>
                                    <th style="padding:10px 15px;">Probability</th>
                                    <th style="padding:10px 15px;">Total Amount</th>
                                    <th style="padding:10px 15px;">Avg Amount</th>
                                    <th style="padding:10px 15px;">Max Profit</th>
                                    <th style="padding:10px 15px;">Min Profit</th>
                                </tr>
                            </thead>
                            <tbody id="winStreakTableBody"></tbody>
                        </table>
                    </div>
                </div>

                <!-- Table: Losing Streaks -->
                <div id="box-loss-streaks" class="stats-card"
                    style="padding:0; overflow:hidden; justify-content: flex-start;">
                    <div style="padding:15px; background:#1e293b; border-bottom:1px solid #334155;">
                        <div class="stats-card-title">Losing Streaks Distribution</div>
                    </div>
                    <div style="overflow-x:auto;">
                        <table style="width:100%; border-collapse:collapse;">
                            <thead>
                                <tr style="background:#0f172a; color:#94a3b8; font-size:0.85em; text-align:left;">
                                    <th style="padding:10px 15px;">Streak Length</th>
                                    <th style="padding:10px 15px;">Count (Frequency)</th>
                                    <th style="padding:10px 15px;">Probability</th>
                                    <th style="padding:10px 15px;">Total Amount</th>
                                    <th style="padding:10px 15px;">Avg Amount</th>
                                    <th style="padding:10px 15px;">Smallest Loss</th>
                                    <th style="padding:10px 15px;">Biggest Loss</th>
                                </tr>
                            </thead>
                            <tbody id="lossStreakTableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB 4: HISTORY -->
        <div id="tab-history" class="tab-content">


            <div class="glass-panel">
                <div class="section-title">Monthly Breakdown</div>
                <!-- Monthly Stats Table -->
                <div id="panel-history-monthly" style="overflow-x: auto; margin-bottom: 25px;">
                    <table id="monthlyTable" style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th id="periodHeader">Month</th>
                                <th>Net P&L</th>
                                <th>Cumulative P&L</th>
                                <th>Count</th>
                                <th>Wins</th>
                                <th>Losses</th>
                                <th>Win%</th>
                                <th>Run-up</th>
                                <th>Drawdown</th>
                                <th>File</th>
                            </tr>
                        </thead>
                        <tbody id="tableBody"></tbody>
                    </table>
                </div>
            </div>

            <div class="glass-panel">
                <div class="section-title">Monthly P&L by File</div>
                <div style="overflow-x: auto;">
                    <table id="fileBreakdownTable">
                        <thead id="fileBreakdownHead"></thead>
                        <tbody id="fileBreakdownBody"></tbody>
                    </table>
                </div>
            </div>

            <div class="glass-panel" id="coincidentPanel" style="display:none;">
                <div class="section-title">Coincident Dates Analysis (Multiple Files)</div>
                <div style="margin-bottom:10px; font-size:0.9em; color:var(--text-secondary);">
                    Dates where trades occurred in more than one file simultaneously.
                </div>
                <div style="overflow-x: auto;">
                    <table id="coincidentTable" style="width:100%;">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Total P&L</th>
                                <th>File Count</th>
                                <th style="width:60%;">File Breakdown</th>
                            </tr>
                        </thead>
                        <tbody id="coincidentBody"></tbody>
                    </table>
                </div>
            </div>



            <div id="panel-history-daily" class="glass-panel">
                <div class="section-title">Trade History</div>
                <div style="overflow-x: auto;">
                    <table id="tradeListTable" style="width: 100%; border-collapse: collapse; margin-top: 20px;">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Net P&L</th>
                                <th>Cumulative P&L</th>
                                <th>Count</th>
                                <th>Wins</th>
                                <th>Losses</th>
                                <th>Win%</th>
                                <th>Run-up</th>
                                <th>Drawdown</th>
                                <th>File</th>
                            </tr>
                        </thead>
                        <tbody id="tradeListBody"></tbody>
                    </table>
                </div>
            </div>

            <div style="margin-top: 30px; border-left: 4px solid #cf6679; padding-left: 10px; opacity: 0.5;">
                <strong>Debug:</strong> Last 5 Parsed Trades
                <div id="debugColumnInfo"
                    style="font-size:0.75em; color:#94a3b8; margin-bottom:6px; font-family:monospace;"></div>
                <div style="font-size: 0.8em; margin-top: 5px;">
                    <table style="width: auto;">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Type</th>
                                <th>P&L</th>
                            </tr>
                        </thead>
                        <tbody id="debugTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <footer>
            Generated by Google Deepmind & Antigravity
        </footer>
    </div>

    <script>
        // --- Navigation ---
        function switchTab(tabId) {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            const btn = document.querySelector(`button[onclick="switchTab('${tabId}')"]`);
            if (btn) btn.classList.add('active');

            const content = document.getElementById('tab-' + tabId);
            if (content) content.classList.add('active');
        }

        function goToStreak(type) {
            switchTab('streaks');
            setTimeout(() => {
                const id = type === 'win' ? 'box-win-streaks' : 'box-loss-streaks';
                const el = document.getElementById(id);
                if (el) {
                    el.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // Flash effect
                    el.style.transition = 'box-shadow 0.3s ease';
                    el.style.boxShadow = '0 0 0 2px var(--accent-color)';
                    setTimeout(() => el.style.boxShadow = 'none', 1000);
                }
            }, 100);
        }

        function goToHistory(section) {
            switchTab('history');
            setTimeout(() => {
                const id = section === 'monthly' ? 'panel-history-monthly' : 'panel-history-daily';
                const el = document.getElementById(id);
                if (el) {
                    el.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // Flash effect
                    el.style.transition = 'box-shadow 0.3s ease';
                    el.style.boxShadow = '0 0 0 2px var(--accent-color)';
                    setTimeout(() => el.style.boxShadow = 'none', 1000);
                }
            }, 100);
        }

        function applyHistoryFilter(start, end) {
            // Robust parsing for "YYYY-MM-DD"
            const parseYMD = (s) => {
                if (!s) return null;
                const parts = s.split('-');
                if (parts.length === 3) return new Date(parts[0], parts[1] - 1, parts[2]); // Local Time
                return new Date(s);
            };

            const startDate = parseYMD(start);
            const endDate = parseYMD(end);
            if (endDate) endDate.setHours(23, 59, 59, 999);

            const subset = parsedTrades.filter(t => {
                if (hiddenFiles.has(t.sourceFile)) return false;
                if (!t.timestamp) return false;
                // t.timestamp is derived from Local Date construction in parseDate
                const d = new Date(t.timestamp);
                return (!startDate || d >= startDate) && (!endDate || d <= endDate);
            });

            // Ensure chronological order for correct Drawdown Calculation
            subset.sort((a, b) => a.timestamp - b.timestamp);

            // Prepare Full Data (respecting hidden files) for "Back Mode" context
            const fullData = parsedTrades.filter(t => !hiddenFiles.has(t.sourceFile));
            // Sort full data too just in case
            fullData.sort((a, b) => a.timestamp - b.timestamp);

            // Update History Analysis (Monthly, Charts) -> FULL DATA
            updateView(fullData);
            renderEquityCurve(fullData);

            // Update Trade List -> FILTERED SUBSET ONLY
            renderTradeList(subset);

            // Navigate
            goToHistory('daily');
        }

        // --- Core Logic ---
        let parsedTrades = [];
        let savedMultipliers = {};
        let savedCapitals = {};
        let savedSlippage = {}; // New: Store Slippage per file
        let hiddenFiles = new Set();
        let latestFileMeta = null; // Global to store debug info
        // No global multiplier variable needed, read from DOM dynamically

        // GLOBAL FORMATTER (Used by renderStreakAnalysis and others)
        const fmtMoney = (v) => new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(v);
        const fmt = fmtMoney; // Alias for backward compatibility

        // Function to update multiplier and re-render
        function updateMultipliers() {
            // Update Global State from DOM
            const multInputs = document.querySelectorAll('#fileControlsList input.chip-input:not(.cap-input):not(.slip-input)'); // Exclude cap/slip
            multInputs.forEach(inp => {
                const val = parseFloat(inp.value);
                savedMultipliers[inp.getAttribute('data-filename')] = isNaN(val) ? 1 : val;
            });

            const capInputs = document.querySelectorAll('#fileControlsList input.cap-input');
            capInputs.forEach(inp => {
                const val = parseFloat(inp.value);
                savedCapitals[inp.getAttribute('data-filename')] = isNaN(val) ? 35000 : val;
            });

            const slipInputs = document.querySelectorAll('#fileControlsList input.slip-input');
            slipInputs.forEach(inp => {
                const val = parseFloat(inp.value);
                savedSlippage[inp.getAttribute('data-filename')] = isNaN(val) ? 0 : val;
            });

            if (parsedTrades.length > 0) {
                // Re-calculate live values from originals
                parsedTrades.forEach(t => {
                    const factor = savedMultipliers[t.sourceFile] !== undefined ? savedMultipliers[t.sourceFile] : 1;
                    const slipPct = savedSlippage[t.sourceFile] !== undefined ? savedSlippage[t.sourceFile] : 0;
                    const capital = savedCapitals[t.sourceFile] !== undefined ? savedCapitals[t.sourceFile] : 35000;

                    if (t.originalPnl !== undefined) {
                        // Apply Multiplier AND Slippage
                        // Slippage is % of Traded Capital
                        const totalSlip = (capital * factor) * (slipPct / 100);
                        t.pnl = (t.originalPnl * factor) - totalSlip;
                    }
                    if (t.originalFileRunUp !== undefined) t.fileRunUp = t.originalFileRunUp * factor;
                    if (t.originalFileDrawdown !== undefined) t.fileDrawdown = t.originalFileDrawdown * factor;
                });

                // Apply Filters (Date) then Render
                applyFilters();
            }
        }

        function applyFilters() {
            const startStr = document.getElementById('startDateInput').value;
            const endStr = document.getElementById('endDateInput').value;

            let filtered = parsedTrades.filter(t => !hiddenFiles.has(t.sourceFile));

            // Date Filter
            if (startStr || endStr) {
                const startTs = startStr ? new Date(startStr).getTime() : 0;
                // End date: set to end of that day (23:59:59)
                const endTs = endStr ? new Date(endStr).setHours(23, 59, 59, 999) : Number.MAX_SAFE_INTEGER;

                filtered = filtered.filter(t => {
                    return t.timestamp >= startTs && t.timestamp <= endTs;
                });
            }

            calculateAndRender(filtered);

            // Prioritize Streak Analysis (User Focus)
            try { renderStreakAnalysis(filtered); } catch (e) { console.error(e); }

            calculateTargetHit(filtered); // Pass filtered data
            calculateDrawdownHit(filtered);

            // Validate and update other tabs as well
            try { if (typeof renderCharts === 'function') renderCharts(filtered); } catch (e) { console.error(e); }
            try { if (typeof renderTradeHistory === 'function') renderTradeHistory(filtered); } catch (e) { console.error(e); }
            try { if (typeof renderTimeAnalysis === 'function') renderTimeAnalysis(filtered); } catch (e) { console.error(e); }
        }

        function clearDateFilters() {
            document.getElementById('startDateInput').value = '';
            document.getElementById('endDateInput').value = '';
            applyFilters();
        }

        function toggleFileVisibility(name) {
            if (hiddenFiles.has(name)) hiddenFiles.delete(name);
            else hiddenFiles.add(name);

            // Scrape current state
            const mults = {};
            const caps = {};
            const slips = {};

            document.querySelectorAll('#fileControlsList input.chip-input:not(.cap-input):not(.slip-input)').forEach(inp => mults[inp.getAttribute('data-filename')] = inp.value);
            document.querySelectorAll('#fileControlsList input.cap-input').forEach(inp => caps[inp.getAttribute('data-filename')] = inp.value);
            document.querySelectorAll('#fileControlsList input.slip-input').forEach(inp => slips[inp.getAttribute('data-filename')] = inp.value);

            // Re-render controls
            const uniqueFiles = [...new Set(parsedTrades.map(t => t.sourceFile).filter(Boolean))];
            renderFileControls(uniqueFiles, mults, caps, slips);

            // Update Report
            updateMultipliers();
        }

        function deleteFile(name) {
            if (!confirm(`Delete ${name}?`)) return;

            // Remove from parsedTrades
            parsedTrades = parsedTrades.filter(t => t.sourceFile !== name);
            hiddenFiles.delete(name);

            // Scrape multipliers (excluding deleted)
            const mults = {};
            const caps = {};
            const slips = {};

            document.querySelectorAll('#fileControlsList input.chip-input:not(.cap-input):not(.slip-input)').forEach(inp => {
                const fname = inp.getAttribute('data-filename');
                if (fname !== name) mults[fname] = inp.value;
            });
            document.querySelectorAll('#fileControlsList input.cap-input').forEach(inp => {
                const fname = inp.getAttribute('data-filename');
                if (fname !== name) caps[fname] = inp.value;
            });
            document.querySelectorAll('#fileControlsList input.slip-input').forEach(inp => {
                const fname = inp.getAttribute('data-filename');
                if (fname !== name) slips[fname] = inp.value;
            });

            // Re-render
            const uniqueFiles = [...new Set(parsedTrades.map(t => t.sourceFile).filter(Boolean))];
            renderFileControls(uniqueFiles, mults, caps, slips);

            if (uniqueFiles.length === 0) {
                // Clear report
                document.getElementById('activeFilesPanel').style.display = 'none';
                calculateAndRender([]);
            } else {
                updateMultipliers();
            }
        }

        function handleWheel(evt, inp) {
            evt.preventDefault();
            const delta = evt.deltaY < 0 ? 0.1 : -0.1;
            let val = parseFloat(inp.value);
            if (isNaN(val)) val = 1;
            val = Math.round((val + delta) * 10) / 10;
            if (val < 0) val = 0;
            inp.value = val;
            updateMultipliers();
        }

        function handleGroupWheel(evt, group) {
            const inp = group.querySelector('input');
            if (inp) handleWheel(evt, inp);
        }

        function adjustMult(name, delta, btn) {
            const container = btn.closest('.chip-input-group');
            const inp = container.querySelector('input');
            let val = parseFloat(inp.value);
            if (isNaN(val)) val = 1;
            val = Math.round((val + delta) * 10) / 10;
            // if (val < 0) val = 0; // Optional constrain
            inp.value = val;
            updateMultipliers();
        }

        // New Helper for Slippage
        function adjustSlip(name, delta, btn) {
            const container = btn.closest('.chip-input-group');
            const inp = container.querySelector('input');
            let val = parseFloat(inp.value);
            if (isNaN(val)) val = 0;
            val = Math.round((val + delta) * 100) / 100; // Round to 2 decimals
            if (val < 0) val = 0;
            inp.value = val;
            updateMultipliers();
        }

        function handleSlipWheel(evt, inp) {
            evt.preventDefault();
            const delta = evt.deltaY < 0 ? 0.05 : -0.05; // Scroll step 0.05
            let val = parseFloat(inp.value);
            if (isNaN(val)) val = 0;
            val = Math.round((val + delta) * 100) / 100;
            if (val < 0) val = 0;
            inp.value = val;
            updateMultipliers();
        }

        function handleSlipGroupWheel(evt, group) {
            const inp = group.querySelector('input');
            if (inp) handleSlipWheel(evt, inp);
        }

        function handleFileSelect(evt, isMerge = false) {
            const files = evt.target.files;
            if (!files.length) return;

            const promises = [];
            for (let i = 0; i < files.length; i++) {
                promises.push(processFile(files[i]));
            }

            Promise.all(promises).then(results => {
                const newTrades = results.flat();

                if (newTrades.length === 0) {
                    alert("No valid trades found!");
                    return;
                }

                if (isMerge) {
                    // Check Date Range overlap
                    const startStr = document.getElementById('startDateInput').value;
                    const endStr = document.getElementById('endDateInput').value;
                    if (startStr || endStr) {
                        const startTs = startStr ? new Date(startStr).getTime() : 0;
                        const endTs = endStr ? new Date(endStr).setHours(23, 59, 59, 999) : Number.MAX_SAFE_INTEGER;

                        const hasOverlap = newTrades.some(t => t.timestamp >= startTs && t.timestamp <= endTs);
                        if (!hasOverlap) {
                            if (confirm("Warning: The merged trades are outside your current Date Filter range and will not be visible.\n\nClear date filters to view them?")) {
                                clearDateFilters();
                            }
                        }
                    }

                    // Append mode
                    // Optionally deduplicate? For now, we assume user adds different files.
                    parsedTrades = parsedTrades.concat(newTrades);
                } else {
                    // Overwrite mode
                    parsedTrades = newTrades;
                    hiddenFiles.clear(); // Reset hidden on new report
                }

                if (parsedTrades.length === 0) {
                    alert("No valid trades found!");
                    return;
                }

                // Collect existing multipliers and capitals if merge
                let currentMults = {};
                let currentCaps = {};
                let currentSlips = {};

                if (isMerge) {
                    document.querySelectorAll('#fileControlsList input.chip-input:not(.cap-input):not(.slip-input)').forEach(inp => {
                        currentMults[inp.getAttribute('data-filename')] = inp.value;
                    });
                    document.querySelectorAll('#fileControlsList input.cap-input').forEach(inp => {
                        currentCaps[inp.getAttribute('data-filename')] = inp.value;
                    });
                    document.querySelectorAll('#fileControlsList input.slip-input').forEach(inp => {
                        currentSlips[inp.getAttribute('data-filename')] = inp.value;
                    });
                }

                // Extract unique files
                const uniqueFiles = [...new Set(parsedTrades.map(t => t.sourceFile).filter(Boolean))];

                // Render controls (preserve mults if merge)
                renderFileControls(uniqueFiles, currentMults, currentCaps, currentSlips);

                // Initial update
                updateMultipliers();

                // Ensure panel visible
                document.getElementById('activeFilesPanel').style.display = 'block';

                // Reset inputs
                document.getElementById('csvFileInput').value = '';
                document.getElementById('mergeFileInput').value = '';
            });
        }

        function renderFileControls(files, savedMultipliers = {}, savedCapitals = {}, savedSlippage = {}) {
            const container = document.getElementById('fileControlsList');
            const panel = document.getElementById('activeFilesPanel');

            if (!container) return;
            container.innerHTML = '';

            let names = [];
            if (files[0] && files[0].name) names = files.map(f => f.name);
            else names = files;

            if (names.length > 0 && panel) {
                panel.style.display = 'block'; // Show panel when files exist
            }

            names.sort().forEach(name => {
                const initialVal = savedMultipliers[name] !== undefined ? savedMultipliers[name] : 1;
                const initialCap = savedCapitals[name] !== undefined ? savedCapitals[name] : 35000;
                const initialSlip = savedSlippage[name] !== undefined ? savedSlippage[name] : 0;
                const isHidden = hiddenFiles.has(name);

                const div = document.createElement('div');
                div.className = `file-chip ${isHidden ? 'hidden' : ''}`;

                // HTML Icons
                const eyeIcon = isHidden
                    ? `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" /></svg>`
                    : `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path stroke-linecap="round" stroke-linejoin="round" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>`;

                const trashIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>`;

                div.innerHTML = `
                    <div class="chip-name" title="${name}">${name}</div>
                    
                    <div class="chip-actions">
                        <button onclick="toggleFileVisibility('${name}')" title="${isHidden ? 'Show' : 'Hide'}" class="chip-btn ${isHidden ? 'hide' : 'show'}">
                            ${eyeIcon}
                        </button>
                        <button onclick="deleteFile('${name}')" title="Delete" class="chip-btn delete">
                            ${trashIcon}
                        </button>
                    </div>

                    <!-- Capital Input -->
                    <div class="chip-input-group" title="Initial Capital">
                        <span style="color:#64748b; font-size:0.8em; margin-right:2px;">₹</span>
                        <input type="number" class="chip-input cap-input" data-filename="${name}" value="${initialCap}" min="0" step="1000" onchange="updateMultipliers()">
                    </div>

                    <!-- Slippage Input (NEW) -->
                    <div class="chip-input-group" title="Slippage % of Capital" onwheel="handleSlipGroupWheel(event, this)">
                        <span style="color:#ef4444; font-size:0.8em; margin-right:2px;">%</span>
                        <input type="number" class="chip-input slip-input" data-filename="${name}" value="${initialSlip}" min="0" step="0.05" onchange="updateMultipliers()">
                        <div class="spinner-btns">
                            <button class="spin-btn up" onclick="adjustSlip('${name}', 0.05, this)">▲</button>
                            <button class="spin-btn down" onclick="adjustSlip('${name}', -0.05, this)">▼</button>
                        </div>
                    </div>

                    <!-- Multiplier Input -->
                    <div class="chip-input-group" onwheel="handleGroupWheel(event, this)">
                        <span style="color:#64748b; font-size:0.8em; margin-right:2px;">x</span>
                        <input type="number" class="chip-input" data-filename="${name}" value="${initialVal}" min="0" step="0.1" onchange="updateMultipliers()">
                        <div class="spinner-btns">
                            <button class="spin-btn up" onclick="adjustMult('${name}', 0.1, this)">▲</button>
                            <button class="spin-btn down" onclick="adjustMult('${name}', -0.1, this)">▼</button>
                        </div>
                    </div>
                `;
                container.appendChild(div);
            });

            // Add Merge Button logic... (restored in next steps if needed, or included here)
            const addBtn = document.createElement('div');
            addBtn.className = 'file-chip add-btn';
            addBtn.style.justifyContent = 'center';
            addBtn.style.cursor = 'pointer';
            addBtn.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="#10b981" stroke-width="2.5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" />
                </svg>
            `;
            addBtn.onclick = () => document.getElementById('mergeFileInput').click();
            addBtn.title = "Add/Merge Document";
            addBtn.onmouseover = function () { this.style.backgroundColor = 'rgba(16, 185, 129, 0.3)'; };
            addBtn.onmouseout = function () { this.style.backgroundColor = 'rgba(16, 185, 129, 0.2)'; };

            container.appendChild(addBtn);
        }

        document.addEventListener('DOMContentLoaded', () => {
            const fileInput = document.getElementById('csvFileInput');
            const mergeInput = document.getElementById('mergeFileInput');
            renderLibraryList();

            // Handle New Report Upload (Overwrite)
            fileInput.addEventListener('change', (e) => handleFileSelect(e, false));

            // Handle Merge Upload (Append)
            mergeInput.addEventListener('change', (e) => handleFileSelect(e, true));

            // Enable Enter key to save
            const portfolioInput = document.getElementById('portfolioNameInput');
            if (portfolioInput) {
                portfolioInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') saveToLibrary();
                });
            }

            // Old Duplicate Listener Removed
        });

        const processFile = (file) => {
            return new Promise((resolve, reject) => {
                const fileName = file.name.toLowerCase();
                const reader = new FileReader();

                if (fileName.endsWith('.csv')) {
                    reader.onload = (e) => {
                        const trades = processCSV(e.target.result);
                        trades.forEach(t => t.sourceFile = file.name); // Using file.name (original case) or fileName (lower)? User said "give the name". Original case usually better.
                        resolve(trades);
                    };
                    reader.readAsText(file);
                } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
                    reader.onload = (e) => {
                        if (typeof XLSX === 'undefined') reject(new Error("SheetJS not loaded"));
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const sheet = workbook.Sheets[workbook.SheetNames[0]];
                        const trades = processCSV(XLSX.utils.sheet_to_csv(sheet));
                        trades.forEach(t => t.sourceFile = file.name);
                        resolve(trades);
                    };
                    reader.readAsArrayBuffer(file);
                } else if (fileName.endsWith('.json')) {
                    reader.onload = (e) => {
                        const trades = JSON.parse(e.target.result);
                        if (Array.isArray(trades)) {
                            trades.forEach(t => {
                                if (!t.sourceFile) t.sourceFile = file.name;
                                // Store originals for Multiplier (if not already present in JSON)
                                if (t.originalPnl === undefined) t.originalPnl = t.pnl;
                                if (t.originalFileRunUp === undefined && t.fileRunUp !== undefined) t.originalFileRunUp = t.fileRunUp;
                                if (t.originalFileDrawdown === undefined && t.fileDrawdown !== undefined) t.originalFileDrawdown = t.fileDrawdown;
                            });
                        }
                        resolve(trades);
                    };
                    reader.readAsText(file);
                } else {
                    reject(new Error("Unsupported file"));
                }
            });
        };

        // Helper for JSON Load to render controls
        // Not straightforward because 'processFile' is per file but we render controls for all.
        // If loading JSON, it's usually single file representing portfolio.
        // Wait, if we load JSON, verify if it contains multiple sourceFiles? 
        // If it was exported from this tool, it might be an array of trades with 'sourceFile' prop.
        // We need to extract unique sourceFiles from the parsed trades to render controls.
        // We'll do this in the main event listener.

        function processCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const trades = [];
            if (lines.length < 2) return [];

            const header = lines[0].toLowerCase().split(',');
            // Column detection logic
            let typeIdx = -1, dateIdx = -1, timeIdx = -1, pnlIdx = -1, runupIdx = -1, drawdownIdx = -1;
            let exitDateIdx = -1;
            let exitTimeIdx = -1;
            let priceIdx = -1; // New Price Column
            let tradeNumIdx = -1; // Trade ID for matching Entry/Exit pairs
            let netPnlFound = false;

            const clean = (s) => s.replace(/[^a-z0-9\/ %#-]/g, '').trim(); // Remove BOM and weird chars

            header.forEach((col, i) => {
                const c = clean(col);
                const norm = c.replace(/[^a-z0-9]/g, '');

                // Relaxed Type matching
                if (c.includes('type') || c.includes('side') || c.includes('direction') || c.includes('signal')) typeIdx = i;

                // Safe Date matching: Prioritize ENTRY/OPEN date
                // Check if this column is explicitly an ENTRY or OPEN date/time
                const isEntry = c.includes('entry') || c.includes('open');
                const isExit = c.includes('exit') || c.includes('close');
                const hasDate = c.includes('date');
                const hasTime = c.includes('time');

                // 1. Entry Date (Date Only or Date/Time)
                if (isEntry && hasDate) {
                    dateIdx = i;
                }
                // 2. Entry Time (Time Only)
                else if (isEntry && hasTime && !hasDate) {
                    timeIdx = i;
                }

                // Generic Fallbacks (if no Entry Date found yet)
                // Use relaxed check but strictly ignore exit columns
                else if (dateIdx === -1 && !isExit && (hasDate || c === 'date/time' || c === 'trade date')) {
                    dateIdx = i;
                }
                // Generic Time Fallback
                else if (timeIdx === -1 && !isExit && (c === 'time' || c === 'time only')) {
                    timeIdx = i;
                }
                else if (isExit && hasDate) {
                    exitDateIdx = i; // Store as potential fallback, don't set dateIdx yet
                }

                // Explicit Time Column (if separate)
                // Look for "Time" or "Entry Time" but NOT "Date/Time" (which is both)
                // and NOT "Exit Time" unless we want to fallback? No, precise entry time.
                const isTimeOnly = (c === 'time' || c === 'entry time' || c === 'open time');
                if (isTimeOnly) {
                    timeIdx = i;
                }

                const isExitTimeOnly = (c === 'exit time' || c === 'close time' || c === 'closing time');
                if (isExitTimeOnly) {
                    exitTimeIdx = i;
                }

                // Check for Percentage
                const isPct = c.includes('%') || norm.includes('percent') || norm.includes('pct');

                // Price Detection (Excluding P&L and other non-price numericals if possible)
                // Look for: "Price", "Rate", "Avg Price", "Price INR"
                if (priceIdx === -1 && !isPct && (c === 'price' || c === 'rate' || c === 'avg. price' || c === 'price inr' || c === 'fill price')) {
                    priceIdx = i;
                }

                // Run-up / Drawdown matching
                // Must exclude percentages to avoid capturing "Run-up %"
                if ((norm.includes('runup') || norm.includes('runupinr')) && !isPct) runupIdx = i;
                if (norm.includes('drawdown') && !isPct) drawdownIdx = i;

                // Safe PnL matching logic with Priority
                // Priority 1: "Net Realized P&L" (Common in some reports)
                // Priority 2: explicitly "Net P&L" or "Net Profit"
                // Priority 3: Contains "P&L" or "Profit" but excludes Cumulative/Runup

                const isRealized = c.includes('realized') && (c.includes('p&l') || c.includes('profit') || c.includes('pl'));
                const isNet = (c.includes('net') && (c.includes('p&l') || c.includes('profit') || c.includes('pl')));
                const isGeneric = (c.includes('p&l') || c.includes('profit') || c.includes('gain') || c.includes('loss') || c === 'amount');
                const excluded = norm.includes('cumulative') || norm.includes('runup') || norm.includes('drawdown') || c.includes('%') || c.includes('percent');

                if (!excluded) {
                    if (isRealized && !c.includes('unrealized')) {
                        pnlIdx = i;
                        netPnlFound = true; // Treat realized as definitive
                    } else if (isNet && !netPnlFound) {
                        pnlIdx = i;
                        netPnlFound = true;
                    } else if (isGeneric && !netPnlFound) {
                        pnlIdx = i;
                    }
                }

                // Trade Number Detection
                const cNoSpace = c.replace(/\s+/g, '');
                if (c === '#' || c === 'id' || cNoSpace === 'trade#' || cNoSpace === 'tradeno' || cNoSpace === 'tradenumber' || cNoSpace === 'tradeid' || cNoSpace === 'refno' || c === 'ref') {
                    tradeNumIdx = i;
                }
            });

            // Fallbacks
            if (typeIdx === -1) typeIdx = 1;
            if (dateIdx === -1) {
                // Try finding any date col
                if (exitDateIdx !== -1) {
                    dateIdx = exitDateIdx; // Use Exit Date only if no Entry Date found
                } else {
                    header.forEach((col, i) => { if ((col.includes('date') || col.includes('time')) && dateIdx === -1) dateIdx = i; });
                    if (dateIdx === -1) dateIdx = 2; // Last Resort
                }
            }
            if (pnlIdx === -1) pnlIdx = 7;

            // Heuristic for Number Format (EU vs US)
            let isEuFormat = false; // Default US (1,234.56)
            let commaDecimals = 0;
            let dotDecimals = 0;

            for (let i = 1; i < Math.min(lines.length, 10); i++) {
                const cols = lines[i].split(',');
                if (cols.length > pnlIdx) {
                    const raw = cols[pnlIdx];
                    if (!raw) continue;
                    const lastComma = raw.lastIndexOf(',');
                    const lastDot = raw.lastIndexOf('.');
                    if (lastComma > lastDot && lastComma > -1) commaDecimals++;
                    if (lastDot > lastComma && lastDot > -1) dotDecimals++;
                }
            }
            if (commaDecimals > dotDecimals) isEuFormat = true;
            if (commaDecimals > dotDecimals) isEuFormat = true;
            console.log("Detected Number Format: " + (isEuFormat ? "EU" : "US"));

            // Helper to parse money (Hoisted within processCSV to access isEuFormat)
            function parseMoney(str) {
                if (!str) return 0;
                let val = str.trim();
                val = val.replace(/[^0-9.,\-()]/g, '');
                let isNeg = false;
                if (val.startsWith('(') && val.endsWith(')')) { isNeg = true; val = val.slice(1, -1); }
                if (isEuFormat) val = val.replace(/\./g, '').replace(/,/g, '.');
                else val = val.replace(/,/g, '');
                let num = parseFloat(val);
                if (isNaN(num)) return 0;
                return isNeg ? -Math.abs(num) : num;
            }

            // PASS 1: CACHE ENTRIES (Handle Reverse Order)
            const entryCache = {}; // Map<TradeNum, { dateStr: string, signal: string }>

            for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].split(',');
                if (cols.length <= Math.max(typeIdx, dateIdx)) continue;

                if (typeIdx > -1) {
                    const type = cols[typeIdx];
                    if (!type) continue;
                    const isEntry = type.toLowerCase().includes('entry') || type.toLowerCase().includes('open');

                    if (isEntry && tradeNumIdx !== -1) {
                        // Normalize ID: remove spaces/symbols, lower case
                        const tradeId = cols[tradeNumIdx].replace(/[^a-z0-9]/gi, '');
                        let dStr = cols[dateIdx];
                        if (timeIdx !== -1 && cols[timeIdx]) {
                            if (dStr && !dStr.includes(':')) dStr += ' ' + cols[timeIdx];
                        }
                        if (dStr) {
                            let ePrice = 0;
                            if (priceIdx !== -1 && cols[priceIdx]) {
                                ePrice = parseFloat(cols[priceIdx].replace(/[^0-9.]/g, '')) || 0;
                            }
                            entryCache[tradeId] = { date: dStr, signal: type, price: ePrice };
                        }
                    }
                }
            }

            // PASS 2: PROCESS EXITS (Build Trades)
            for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].split(',');
                if (cols.length <= Math.max(typeIdx, dateIdx, pnlIdx)) continue;

                let isExit = false;
                let currentType = '';

                // 1. Check Explicit Type
                if (typeIdx !== -1 && cols[typeIdx]) {
                    currentType = cols[typeIdx];
                    const tLower = currentType.toLowerCase();
                    const isEntry = tLower.includes('entry') || tLower.includes('open');
                    // Explicit Exit?
                    if (tLower.includes('exit') || tLower.includes('close')) {
                        isExit = true;
                    }

                    if (isEntry) continue; // Always skip explicitly marked entries in Pass 2
                }

                // 2. Check Implicit Exit via P&L
                // If not marked as exit yet, check if it has valid P&L
                if (!isExit) {
                    let pnlVal = 0;
                    if (pnlIdx !== -1 && cols.length > pnlIdx) {
                        pnlVal = parseMoney(cols[pnlIdx]);
                    }
                    // If non-zero P&L, treat as Exit (e.g. "Buy" or "Sell" row with profit)
                    if (Math.abs(pnlVal) > 0.0001) {
                        isExit = true;
                    }
                }

                // 3. Final Check
                if (!isExit) continue; // Skip if neither explicit nor implicit exit

                // Ensure data validity
                if (cols.length <= pnlIdx) continue;

                let dateStr = cols[dateIdx];

                // If we also found a separate Time column, append it
                // DEFAULT behavior: use timeIdx (which is likely Entry Time).
                // But for Exit Rows, we might want to check exitTimeIdx first?
                // Actually, let's capture the 'dateStr' as-is for now, and strictly fix it in the Exit Capture block below.
                if (timeIdx !== -1 && cols[timeIdx]) {
                    if (dateStr && !dateStr.includes(':')) {
                        dateStr += ' ' + cols[timeIdx];
                    }
                }

                // Capture EXIT Data (before we overwrite with Entry Cache)
                // Since Pass 2 iterates Exit rows by default (lines 1460+), 'dateStr', 'cols[timeIdx]', and 'signalName' are currently Exit data.
                let signalName = (typeIdx > -1 && cols[typeIdx]) ? cols[typeIdx] : '';
                const exitSignal = signalName || '';

                // Build Specific Exit Date/Time String
                // If we have a specific Exit Time Column, prefer that over the standard Time Column (which might be Entry Time)
                let rawExitDateStr = cols[dateIdx];
                if (exitTimeIdx !== -1 && cols[exitTimeIdx]) {
                    // Use the specific Exit Time column
                    if (rawExitDateStr && !rawExitDateStr.includes(':')) {
                        rawExitDateStr += ' ' + cols[exitTimeIdx];
                    }
                } else if (timeIdx !== -1 && cols[timeIdx]) {
                    // Fallback to standard Time column (might be same as Entry Time if CSV is weird)
                    if (rawExitDateStr && !rawExitDateStr.includes(':')) {
                        rawExitDateStr += ' ' + cols[timeIdx];
                    }
                }

                const exitDateVal = parseDate(rawExitDateStr); // Use helper to parse Exit Date/Time
                let exitTimeStr = '';
                let exitHour = 0;
                let exitMinute = 0;

                if (exitDateVal) {
                    exitHour = exitDateVal.getHours();
                    exitMinute = exitDateVal.getMinutes();
                    exitTimeStr = `${String(exitHour).padStart(2, '0')}:${String(exitMinute).padStart(2, '0')}`;
                }

                // Capture EXIT PRICE
                let exitPrice = 0;
                if (priceIdx !== -1 && cols[priceIdx]) {
                    exitPrice = parseFloat(cols[priceIdx].replace(/[^0-9.]/g, '')) || 0;
                }

                // CHECK CACHE for Entry Time (Override current row's time)
                if (tradeNumIdx !== -1) {
                    const tradeId = cols[tradeNumIdx].replace(/[^a-z0-9]/gi, '');
                    if (entryCache[tradeId]) {
                        dateStr = entryCache[tradeId].date; // Use the cached Entry Date!
                        if (entryCache[tradeId].signal) {
                            signalName = entryCache[tradeId].signal;
                        }
                        if (entryCache[tradeId].price) {
                            // Store Entry Price if found in cache
                            cols['entryPrice'] = entryCache[tradeId].price; // Temporary storage on cols array logic? No, let's use a variable.
                        }
                    }
                }

                // Retrieve cached Entry Price properly
                let entryPrice = 0;
                if (tradeNumIdx !== -1) {
                    const tradeId = cols[tradeNumIdx].replace(/[^a-z0-9]/gi, '');
                    if (entryCache[tradeId] && entryCache[tradeId].price) {
                        entryPrice = entryCache[tradeId].price;
                    }
                }

                // Fallback: If signal still says "Exit", force it to "Entry" format
                // This handles cases where cache lookup fails but we know the direction from the Exit signal.
                // Fallback Removed per user request ("no automatically renames")
                // We rely on Two-Pass Cache to find the correct Entry Signal.
                // if (signalName && signalName.toLowerCase().includes('exit')) ...

                let pnl = 0;
                try {
                    // Cleanup currency symbols
                    if (cols[pnlIdx]) pnl = parseMoney(cols[pnlIdx]);
                } catch (e) { /* ignore */ }
                if (isNaN(pnl)) pnl = 0; // Ensure pnl is a number

                // Parse Run-up / Drawdown if available
                let fileRunUp = undefined;
                let fileDrawdown = undefined;

                if (runupIdx > -1 && cols[runupIdx]) fileRunUp = parseMoney(cols[runupIdx]);
                if (drawdownIdx > -1 && cols[drawdownIdx]) fileDrawdown = parseMoney(cols[drawdownIdx]);

                // Parse Date using the robust parser
                const d = parseDate(dateStr);
                if (!d) continue;

                /* STORE ORIGINALS for Multiplier Logic */
                // Capture TradeId
                let tId = '';
                if (tradeNumIdx !== -1 && cols[tradeNumIdx]) {
                    tId = cols[tradeNumIdx].replace(/[^a-z0-9]/gi, '');
                }

                trades.push({
                    tradeId: tId, // New Field for Dedupe
                    signalName: signalName,
                    exitSignal: exitSignal, // New Field

                    dateStr: dateStr,
                    exitDateStr: exitDateVal ? dateStr : dateStr, // Keep original if needed, but we have fields below

                    month: `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`,
                    daily: `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`,
                    time: `${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`,

                    price: entryPrice,    // Entry Price
                    exitPrice: exitPrice, // Exit Price

                    exitTime: exitTimeStr, // New Field
                    exitHour: exitHour,    // New Field
                    exitMinute: exitMinute,// New Field

                    hour: d.getHours(),
                    minute: d.getMinutes(),
                    timestamp: d.getTime(),

                    pnl: pnl,
                    originalPnl: pnl, // Storing for scaling

                    fileRunUp: fileRunUp > 0 ? fileRunUp : undefined,
                    originalFileRunUp: fileRunUp > 0 ? fileRunUp : undefined,

                    fileDrawdown: fileDrawdown < 0 ? fileDrawdown : undefined,
                    originalFileDrawdown: fileDrawdown < 0 ? fileDrawdown : undefined,

                    displayRU: 0, // placeholders
                    displayDD: 0
                });
            }

            // Attach Debug Meta to Global
            latestFileMeta = {
                dateIdx, pnlIdx, typeIdx,
                pnlColName: pnlIdx > -1 ? header[pnlIdx] : 'N/A',
                dateColName: dateIdx > -1 ? header[dateIdx] : 'N/A'
            };

            // DEDUPLICATION STEP
            // Remove duplicates where TradeID and P&L are identical (e.g. Entry row has same P&L as Exit row)
            // Or if TradeID missing, use Timestamp + Price + P&L
            const uniqueTrades = [];
            const seenKeys = new Set();

            // Process in reverse? No, linear.
            // If duplicates exist, we keep the FIRST one we encountered (which usually is Entry if file is sorted old->new).
            // Actually, Exit rows usually have the P&L. If Entry has it too... it doesn't matter which we keep as long as data is same.
            // BUT, Exit rows have 'exitTime' populated correctly from my logic?
            // "Entry" rows might lack exit time if I parsed it from current row.
            // The "Real" Exit rows has Date = Exit Date.
            // If I dedupe by TradeID + PNL, I collapse them.
            // I should prefer the one with LATER Date (Exit Date)?

            // Let's Sort by Timestamp FIRST, then Dedupe?
            trades.sort((a, b) => a.timestamp - b.timestamp);

            // Prefer keeping the LAST occurrence (likely the Exit row with correct Exit Date)?
            // Or if I iterate standard, I keep First.
            // If sorted by Time: Entry is First. Exit is Last.
            // If duplicate P&L, I want the Exit row?
            // Actually, if I collapse them, I want the one that represents the trade completion.
            // Usually the Exit row date is what matters for P&L realization.

            // So, let's use a Map by Key, and overwrite (Keep Last).
            const tradeMap = new Map();
            trades.forEach(t => {
                // Key construction
                let key = '';
                if (t.tradeId) {
                    key = t.tradeId + '_' + t.pnl.toFixed(4); // ID + PnL (Strict Dedupe)
                } else {
                    // Fallback: DO NOT DEDUPLICATE if no ID is present.
                    // Treating them as unique prevents valid coincident trades from being lost.
                    // We append a random nonce or index to ensure uniqueness.
                    key = 'no_id_' + Math.random() + '_' + t.timestamp;
                }
                tradeMap.set(key, t); // Overwrite = Keep Last (Exit Row)
            });

            const dedupedInfo = Array.from(tradeMap.values());

            // Re-sort final result just in case
            return dedupedInfo.sort((a, b) => a.timestamp - b.timestamp);
        }
        function parseDate(str) {
            if (!str) return null;
            // distinct date and time
            const [datePart, timePart] = str.trim().split(/\s+/);

            // Try ISO first
            let d = new Date(str);
            if (!isNaN(d.getTime()) && str.includes('-') && (d.getFullYear() > 1900)) return d;

            // Custom parsing for DD-MM-YYYY etc
            if (!datePart) return null;

            const parts = datePart.split(/[-/.]/);
            if (parts.length === 3) {
                let [p1, p2, p3] = parts;
                let y, m, d_val;

                // Heuristics
                if (p1.length === 4) { y = p1; m = p2; d_val = p3; } // YYYY-MM-DD
                else if (p3.length === 4) { d_val = p1; m = p2; y = p3; } // DD-MM-YYYY
                else { d_val = p1; m = p2; y = p3; } // 2-digit year (assume DD-MM-YY)

                if (y.length === 2) y = '20' + y;

                // Month Names
                if (isNaN(parseInt(m))) {
                    const months = { jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6, jul: 7, aug: 8, sep: 9, oct: 10, nov: 11, dec: 12 };
                    m = months[m.substring(0, 3).toLowerCase()] || m;
                }

                // Reconstruct with time if available
                let isoStr = `${y}-${String(m).padStart(2, '0')}-${String(d_val).padStart(2, '0')}`;
                if (timePart) {
                    isoStr += `T${timePart}`;
                }

                d = new Date(isoStr);
                if (!isNaN(d.getTime())) return d;
            }
            return null;
        }

        function calculateAndRender(trades) {
            trades.sort((a, b) => a.timestamp - b.timestamp);

            let totalTrades = trades.length;
            let totalNetPL = trades.reduce((acc, t) => acc + t.pnl, 0);
            let wins = trades.filter(t => t.pnl > 0).length;
            let losses = trades.filter(t => t.pnl <= 0).length;
            let grossProfit = trades.filter(t => t.pnl > 0).reduce((acc, t) => acc + t.pnl, 0);
            let grossLoss = trades.filter(t => t.pnl <= 0).reduce((acc, t) => acc + Math.abs(t.pnl), 0);
            let maxSingleProfit = Math.max(0, ...trades.map(t => t.pnl));
            let maxSingleLoss = Math.min(0, ...trades.map(t => t.pnl));

            // Calculate Total Capital at the start for global % use
            const activeFiles = new Set(trades.map(t => t.sourceFile).filter(Boolean));
            let totalCapital = 0;
            activeFiles.forEach(file => {
                const cap = (savedCapitals[file] !== undefined) ? parseFloat(savedCapitals[file]) : 35000;
                const mult = (savedMultipliers[file] !== undefined) ? parseFloat(savedMultipliers[file]) : 1;
                totalCapital += Math.max(cap, cap * mult);
            });
            const fmtPct = (val) => totalCapital > 0 ? ((val / totalCapital) * 100).toFixed(1) + '%' : '0%';
            // Helper for inline percentage span - SHARP & BRIGHT (No opacity, bold)
            const pctSpan = (val, color = '') => `<span style="font-size:0.85em; margin-left:6px; font-weight:700; ${color ? 'color:' + color : ''}">(${fmtPct(val)})</span>`;

            // Streaks (Count Based)
            let maxWinStreak = 0, currentWinStreak = 0;
            let maxWinStreakAmt = 0, currentWinStreakAmt = 0;
            let maxWinRange = '';

            // Streaks (Value Based - Best/Worst Financial)
            let maxWinStreakVal = 0; // Highest Amt
            let maxWinStreakValCount = 0;
            let maxWinStreakValRange = '';

            let maxLoseStreak = 0, currentLoseStreak = 0;
            let maxLoseStreakAmt = 0, currentLoseStreakAmt = 0;
            let maxLoseRange = '';

            let maxLoseStreakVal = 0; // Most Negative Amt
            let maxLoseStreakValCount = 0;
            let maxLoseStreakValRange = '';

            // Temp vars for range tracking
            let winStart = null;
            let loseStart = null;

            trades.forEach(t => {
                if (t.pnl > 0) {
                    // Win
                    if (currentWinStreak === 0) winStart = t.daily;
                    currentWinStreak++;
                    currentWinStreakAmt += t.pnl;

                    // Update Longest Streak
                    if (currentWinStreak > maxWinStreak) {
                        maxWinStreak = currentWinStreak;
                        maxWinRange = `(${formatDate(winStart)} to ${formatDate(t.daily)})`;
                        maxWinStreakAmt = currentWinStreakAmt;
                    } else if (currentWinStreak === maxWinStreak) {
                        if (currentWinStreakAmt > maxWinStreakAmt) {
                            maxWinStreakAmt = currentWinStreakAmt;
                            maxWinRange = `(${formatDate(winStart)} to ${formatDate(t.daily)})`;
                        }
                    }

                    // Update Richest Streak (Value)
                    if (currentWinStreakAmt > maxWinStreakVal) {
                        maxWinStreakVal = currentWinStreakAmt;
                        maxWinStreakValCount = currentWinStreak;
                        maxWinStreakValRange = `(${formatDate(winStart)} to ${formatDate(t.daily)})`;
                    }

                    currentLoseStreak = 0; currentLoseStreakAmt = 0; loseStart = null;
                } else {
                    // Loss
                    if (currentLoseStreak === 0) loseStart = t.daily;
                    currentLoseStreak++;
                    currentLoseStreakAmt += t.pnl; // negative

                    // Update Longest Streak
                    if (currentLoseStreak > maxLoseStreak) {
                        maxLoseStreak = currentLoseStreak;
                        maxLoseRange = `(${formatDate(loseStart)} to ${formatDate(t.daily)})`;
                        maxLoseStreakAmt = currentLoseStreakAmt;
                    } else if (currentLoseStreak === maxLoseStreak) {
                        if (currentLoseStreakAmt < maxLoseStreakAmt) { // Check most negative
                            maxLoseStreakAmt = currentLoseStreakAmt;
                            maxLoseRange = `(${formatDate(loseStart)} to ${formatDate(t.daily)})`;
                        }
                    }

                    // Update Costliest Streak (Value)
                    if (currentLoseStreakAmt < maxLoseStreakVal) { // More negative is "better" for this metric (worst loss)
                        maxLoseStreakVal = currentLoseStreakAmt;
                        maxLoseStreakValCount = currentLoseStreak;
                        maxLoseStreakValRange = `(${formatDate(loseStart)} to ${formatDate(t.daily)})`;
                    }

                    currentWinStreak = 0; currentWinStreakAmt = 0; winStart = null;
                }
            });

            // Top 3 Biggest Losses
            const allLosses = trades.filter(t => t.pnl < 0).sort((a, b) => a.pnl - b.pnl); // Ascending (most negative first)
            const top3Losses = allLosses.slice(0, 3);

            const elMaxLoss = document.getElementById('maxSingleLossDisplay');
            const elTop3 = document.getElementById('top3LossesList');

            if (elMaxLoss && top3Losses.length > 0) {
                elMaxLoss.textContent = new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(top3Losses[0].pnl);
            } else if (elMaxLoss) {
                elMaxLoss.textContent = '--';
            }

            if (elTop3) {
                if (top3Losses.length > 0) {
                    elTop3.innerHTML = top3Losses.map((l, i) => {
                        return `<div style="display:flex; justify-content:space-between; width:100%; font-size:0.85em; ${(i < 2) ? 'border-bottom:1px solid #334155; padding-bottom:4px; margin-bottom:4px;' : ''}">
                            <span>#${i + 1} <span style="opacity:0.75; font-size:0.9em; margin-left:4px;">${formatDate(l.daily)}</span></span>
                            <span class="text-red" style="font-weight:600;">
                                ${new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(l.pnl)}
                                ${pctSpan(l.pnl)}
                            </span>
                        </div>`;
                    }).join('');
                } else {
                    elTop3.innerHTML = '<span style="opacity:0.5;">No losses recorded</span>';
                }
            }

            // Top 3 Biggest Wins
            const allWins = trades.filter(t => t.pnl > 0).sort((a, b) => b.pnl - a.pnl); // Descending (largest positive first)
            const top3Wins = allWins.slice(0, 3);

            const elMaxWin = document.getElementById('maxSingleProfitDisplay');
            const elTop3Wins = document.getElementById('top3WinsList');

            if (elMaxWin && top3Wins.length > 0) {
                elMaxWin.textContent = new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(top3Wins[0].pnl);
            } else if (elMaxWin) {
                elMaxWin.textContent = '--';
            }

            if (elTop3Wins) {
                if (top3Wins.length > 0) {
                    elTop3Wins.innerHTML = top3Wins.map((w, i) => {
                        return `<div style="display:flex; justify-content:space-between; width:100%; font-size:0.85em; ${(i < 2) ? 'border-bottom:1px solid #334155; padding-bottom:4px; margin-bottom:4px;' : ''}">
                            <span>#${i + 1} <span style="opacity:0.75; font-size:0.9em; margin-left:4px;">${formatDate(w.daily)}</span></span>
                            <span class="text-green" style="font-weight:600;">
                                ${new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(w.pnl)}
                                ${pctSpan(w.pnl)}
                            </span>
                        </div>`;
                    }).join('');
                } else {
                    elTop3Wins.innerHTML = '<span style="opacity:0.5;">No wins recorded</span>';
                }
            }

            // Yearly Stats Aggregation (Months)
            // 1. Aggregate P&L by Month first
            const monthMap = {};
            trades.forEach(t => {
                const ym = t.daily.substring(0, 7); // YYYY-MM
                if (!monthMap[ym]) monthMap[ym] = 0;
                monthMap[ym] += t.pnl;
            });

            // 2. Aggregate Monthly Results by Year
            const yearlyStats = {};
            Object.keys(monthMap).forEach(ym => {
                const y = ym.substring(0, 4);
                const pnl = monthMap[ym];
                if (!yearlyStats[y]) yearlyStats[y] = { wins: 0, losses: 0 };
                if (pnl > 0) yearlyStats[y].wins++;
                else yearlyStats[y].losses++;
            });

            const elYearlyParams = document.getElementById('yearlyStatsList');
            if (elYearlyParams) {
                let htmlY = '';
                Object.keys(yearlyStats).sort().reverse().forEach(y => {
                    const s = yearlyStats[y];
                    htmlY += `<div style="display:flex; align-items:center; justify-content:space-between; font-size:0.8em; border-bottom:1px solid var(--border-color); padding:6px 0;">
                        <span style="opacity:0.9; font-weight:600; font-size:1.1em; color:var(--text-primary);">${y}</span>
                        <div style="white-space:nowrap; font-weight:700;">
                            <span class="text-green" style="margin-right:4px;">${s.wins} M</span>
                            <span style="opacity:0.4; margin:0 4px;">|</span>
                            <span class="text-red">${s.losses} M</span>
                        </div>
                    </div>`;
                });
                if (!htmlY) htmlY = '<span style="opacity:0.5; font-size:0.8em">No Data</span>';
                elYearlyParams.innerHTML = htmlY;
            }

            // Drawdown vars
            let peak = 0;
            let maxDD = 0;
            let running = 0;
            let peakDate = trades.length > 0 ? trades[0].daily : '-';
            let peakTimestamp = trades.length > 0 ? trades[0].timestamp : 0;
            let ddRange = '';

            // Reccovery tracking
            let maxDDPeakValue = 0;
            let maxDDTroughIndex = -1;
            let maxDDTroughTimestamp = 0;

            // Run-up vars
            let maxRunUp = 0;
            let handledRunUp = false;
            let trough = 0;
            let troughDate = trades.length > 0 ? trades[0].daily : '-';
            let runUpRange = '';

            trades.forEach(t => {
                running += t.pnl;

                // Drawdown Logic
                // Drawdown Logic
                if (running > peak) {
                    peak = running;
                    peakDate = t.daily;
                    peakTimestamp = t.timestamp;
                }
                const dd = running - peak;
                if (dd < maxDD) {
                    maxDD = dd;

                    // Track for Recovery
                    maxDDPeakValue = peak;
                    maxDDTroughIndex = trades.indexOf(t); // Note: index in sorted array 'trades'
                    maxDDTroughTimestamp = t.timestamp;

                    const days = Math.floor((t.timestamp - peakTimestamp) / (1000 * 60 * 60 * 24));
                    // Part 1: Drop Block
                    ddRange = `<div onclick="applyHistoryFilter('${peakDate}', '${t.daily}')" style="background:rgba(255,255,255,0.08); padding:8px 10px; border-radius:6px; flex:1; display:flex; flex-direction:column; cursor:pointer;" title="Click to filter this period">
                        <span style="font-size:0.7em; color:#94a3b8; font-weight:600; text-transform:uppercase; letter-spacing:0.5px;">Drop Period</span>
                        <span style="font-size:1.2em; font-weight:800; color:#f1f5f9;">${days} Days</span>
                        <span style="font-size:0.75em; color:#cbd5e1; margin-top:2px;">${formatDate(peakDate)} to ${formatDate(t.daily)}</span>
                    </div>`;
                }

                // Run-up Logic (Inverse of Drawdown)
                // Track lowest low (trough)
                if (running < trough) {
                    trough = running;
                    troughDate = t.daily;
                }
                const ru = running - trough;
                if (ru > maxRunUp) {
                    maxRunUp = ru;
                    runUpRange = `(${formatDate(troughDate)} to ${formatDate(t.daily)})`;
                }

                // Store for Table
                t.currentDD = dd;
                t.currentRU = ru;
                t.currentRU = ru;
            });

            // Calculate Recovery Days
            if (maxDDTroughIndex !== -1) {
                let recoveryFound = false;
                let recoveryDays = 0;
                let tempRunning = maxDDPeakValue + maxDD; // Running P&L at Trough

                let recoveryDateStr = '';

                for (let i = maxDDTroughIndex + 1; i < trades.length; i++) {
                    tempRunning += trades[i].pnl;
                    if (tempRunning >= maxDDPeakValue) {
                        // Recovered!
                        const tRecover = trades[i];
                        recoveryDays = Math.floor((tRecover.timestamp - maxDDTroughTimestamp) / (1000 * 60 * 60 * 24));
                        recoveryDateStr = formatDate(tRecover.daily);
                        recoveryFound = true;
                        break;
                    }
                }

                // Part 2: Recovery Block
                const recText = recoveryFound
                    ? `<div style="background:rgba(245, 158, 11, 0.15); padding:8px 10px; border-radius:6px; flex:1; display:flex; flex-direction:column;">
                        <span style="font-size:0.7em; color:#fdba74; font-weight:600; text-transform:uppercase; letter-spacing:0.5px;">Recovery</span>
                        <span style="font-size:1.2em; font-weight:800; color:#fb923c;">${recoveryDays} Days</span>
                        <span style="font-size:0.75em; color:#fed7aa; margin-top:2px;">End: ${recoveryDateStr}</span>
                       </div>`
                    : `<div style="background:rgba(239, 68, 68, 0.15); padding:8px 10px; border-radius:6px; flex:1; display:flex; flex-direction:column; justify-content:center;">
                        <span style="font-size:0.75em; color:#fca5a5; font-weight:600; text-transform:uppercase; letter-spacing:0.5px;">Status</span>
                        <span style="font-size:1em; font-weight:800; color:#f87171;">Not Recovered</span>
                       </div>`;

                ddRange = `<div style="display:flex; gap:10px; width:100%; margin-top:10px;">${ddRange}${recText}</div>`;
            }
            const hasFileRunUp = trades.some(t => t.fileRunUp !== undefined);
            if (hasFileRunUp) {
                let maxSingleRunUp = 0;
                let maxSingleRunUpDate = '';

                trades.forEach(t => {
                    if (t.fileRunUp > maxSingleRunUp) {
                        maxSingleRunUp = t.fileRunUp;
                        maxSingleRunUpDate = t.daily;
                    }
                });

                if (maxSingleRunUp > 0) {
                    maxRunUp = maxSingleRunUp;

                    // Render HTML directly for the Max Run-up box to show both Max and Min
                    const elVal = document.getElementById('maxRunup');
                    const elDate = document.getElementById('maxRunupDateRange');

                    if (elVal && elDate) {
                        const fmt = (v) => new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(v);

                        // Find Min Run-up
                        let minSingleRunUp = Infinity;
                        let minSingleRunUpDate = '';
                        trades.forEach(t => {
                            if (t.fileRunUp !== undefined) {
                                if (t.fileRunUp < minSingleRunUp) {
                                    minSingleRunUp = t.fileRunUp;
                                    minSingleRunUpDate = t.daily;
                                }
                            }
                        });

                        // If no valid min found (e.g. all undefined), fallback
                        if (minSingleRunUp === Infinity) minSingleRunUp = 0;

                        // Construct HTML
                        // Using smaller font for the label/date parts to fit
                        // Construct HTML
                        // Using smaller font for the label/date parts to fit
                        elVal.innerHTML = `
                            <div style="display:flex; justify-content:space-between; align-items:center; font-size:0.65em; margin-bottom:4px;">
                                <span style="opacity:0.7">MAX</span>
                                <span class="text-green" style="font-size:1.4em; font-weight:700;">
                                    ${fmt(maxSingleRunUp)} ${pctSpan(maxSingleRunUp)}
                                </span>
                            </div>
                            <div style="display:flex; justify-content:space-between; align-items:center; font-size:0.65em;">
                                <span style="opacity:0.7">MIN</span>
                                <span style="font-size:1.1em; font-weight:600; opacity:0.9;">
                                    ${fmt(minSingleRunUp)} ${pctSpan(minSingleRunUp)}
                                </span>
                            </div>
                        `;

                        // Put dates in the bottom range slot
                        elDate.innerHTML = `
                            <div style="display:flex; justify-content:space-between; margin-top: -10px; font-size:0.85em; color:var(--text-primary); font-weight:600;">
                                <span>(${formatDate(maxSingleRunUpDate)})</span>
                                <span>(${formatDate(minSingleRunUpDate)})</span>
                            </div>
                        `;

                        // Prevent standard setText from overwriting this later?
                        // The setText calls are at the end of the function (lines 920-921).
                        // I need to ensure those standard lines don't overwrite this.
                        // I should probably remove the setText calls or update the variables to be empty so setText doesn't clobber,
                        // OR just put this logic AT THE END near the setText calls.
                        // The user wanted "same box".

                        // If I modify this here, the `setText` at lines 920 will overwrite it.
                        // I must modify the setText calls at the bottom OR set a flag.

                        // Better strategy: Update the variables `maxRunUp` and `runUpRange` to contain the HTML string?
                        // setText uses .textContent, so HTML won't render.

                        // I will define a separate render step or variable.
                        handledRunUp = true;
                    }
                }
            }

            // OVERRIDE: Same for Drawdown (Max Single Trade Drawdown)
            const hasFileDrawdown = trades.some(t => t.fileDrawdown !== undefined);
            if (false && hasFileDrawdown) { // UNDO: Reverted to standard Drawdown
                let maxSingleDD = 0; // Want the lowest negative number
                let maxSingleDDDate = '';

                trades.forEach(t => {
                    if (t.fileDrawdown !== undefined) {
                        if (t.fileDrawdown < maxSingleDD) {
                            maxSingleDD = t.fileDrawdown;
                            maxSingleDDDate = t.daily;
                        }
                    }
                });

                if (maxSingleDD < 0) {
                    maxDD = Math.abs(maxSingleDD); // Display as positive number usually, or keep sign?
                    // EXISTING VISUALS: Card usually shows "-$4000" in red.
                    // However, `maxDD` variable is usually POSITIVE in calculation (dd = running - peak, which is negative...)
                    // Wait, original: `dd = running - peak` (negative). `if (dd < maxDD)` (maxDD init 0).
                    // So `maxDD` stores a NEGATIVE number.
                    maxDD = maxSingleDD;
                    ddRange = `(${formatDate(maxSingleDDDate)})`;
                }
            }



            // Display
            const fmt = (v) => new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(v);
            const fmtNum = (v) => new Intl.NumberFormat('en-IN').format(v);

            setText('totalTrades', fmtNum(totalTrades));
            setText('winningTrades', `${wins} (${totalTrades ? ((wins / totalTrades) * 100).toFixed(1) : 0}%)`);
            setText('losingTrades', `${losses} (${totalTrades ? ((losses / totalTrades) * 100).toFixed(1) : 0}%)`);
            setText('winRateDisplay', `${totalTrades ? ((wins / totalTrades) * 100).toFixed(1) : 0}%`);

            // Perform ROI Calculation
            // 1. Identify unique active files in the current filtered set


            // Calculate ROI for display
            const roi = totalCapital > 0 ? ((totalNetPL / totalCapital) * 100).toFixed(1) : 0;
            const roiColor = roi >= 0 ? '#4ade80' : '#f87171';

            // Display Profit + ROI
            const profitEl = document.getElementById('totalNetProfit');
            if (profitEl) {
                const pnlFormatted = fmt(totalNetPL);
                const pnlClass = totalNetPL >= 0 ? 'text-green' : 'text-red';
                profitEl.className = `stats-card-value ${pnlClass}`; // Dynamic Color
                profitEl.innerHTML = `
                    ${pnlFormatted}
                    <div style="font-size:0.6em; margin-top:8px; font-weight:700; color:var(--text-secondary);">
                        ROI: <span style="color:${roiColor}; font-size:1.1em; margin-right:4px;">${roi}%</span>
                        <span style="opacity:0.8; font-size:0.9em; font-weight:500;">(on ${fmt(totalCapital)})</span>
                    </div>
                `;
            }
            // setText('totalNetProfit', fmt(totalNetPL)); // Replaced by block above

            const gpEl = document.getElementById('grossProfit');
            if (gpEl) gpEl.innerHTML = `${fmt(grossProfit)} ${pctSpan(grossProfit)}`;

            const glEl = document.getElementById('grossLoss');
            if (glEl) glEl.innerHTML = `${fmt(-grossLoss)} ${pctSpan(-grossLoss)}`;

            const elDebug = document.getElementById('debugTableBody');
            const elDebugInfo = document.getElementById('debugColumnInfo');

            if (elDebugInfo && latestFileMeta) {
                elDebugInfo.innerHTML = `Dataset Columns: Date='${latestFileMeta.dateColName}' (${latestFileMeta.dateIdx}), P&L='${latestFileMeta.pnlColName}' (${latestFileMeta.pnlIdx})`;
            }

            setText('avgProfit', totalTrades ? fmt(totalNetPL / totalTrades) : fmt(0));

            const valAvgWin = wins ? grossProfit / wins : 0;
            const valAvgLoss = losses ? Math.abs(grossLoss) / losses : 0;
            const avgWinEl = document.getElementById('avgWinner');
            if (avgWinEl) avgWinEl.innerHTML = `${fmt(valAvgWin)} ${pctSpan(valAvgWin)}`;

            const avgLossEl = document.getElementById('avgLoser');
            if (avgLossEl) avgLossEl.innerHTML = `${fmt(-valAvgLoss)} ${pctSpan(-valAvgLoss)}`;

            // Populate Risk Reward Ratio
            const elRr = document.getElementById('rrRatio');
            const elRrWin = document.getElementById('rrAvgWin');
            const elRrLoss = document.getElementById('rrAvgLoss');
            if (elRr && elRrWin && elRrLoss) {
                let ratio = 0;
                if (valAvgLoss > 0) ratio = valAvgWin / valAvgLoss;
                elRr.textContent = `1 : ${ratio.toFixed(2)}`;
                elRr.className = ratio >= 1.5 ? 'stats-card-value text-green' : (ratio >= 1.0 ? 'stats-card-value text-primary' : 'stats-card-value text-red');
                elRrWin.innerHTML = `${fmt(valAvgWin)} ${pctSpan(valAvgWin)}`;
                elRrLoss.innerHTML = `${fmt(-valAvgLoss)} ${pctSpan(-valAvgLoss)}`;
            }

            const maxDDEl = document.getElementById('maxDrawdown');
            if (maxDDEl) maxDDEl.innerHTML = `${fmt(maxDD)} <div style="font-size:0.5em; opacity:0.75; margin-top:4px;">${pctSpan(maxDD)}</div>`;

            const elDD = document.getElementById('maxDrawdownDateRange');
            if (elDD) elDD.innerHTML = ddRange;

            if (!handledRunUp) {
                setText('maxRunup', fmt(maxRunUp));
                setText('maxRunupDateRange', runUpRange);
            }

            // Render Streaks
            const elBestStr = document.getElementById('maxWinStreak');
            const elBestDate = document.getElementById('maxWinStreakDate');
            const elBestAmt = document.getElementById('maxWinStreakAmount');

            if (elBestStr) {
                // Longest Streak
                let html = `<div>${maxWinStreak} <span style="font-size:0.5em; opacity:0.7;">Trades</span></div>`;
                elBestDate.textContent = maxWinStreak > 0 ? maxWinRange : '(-)';

                if (maxWinStreak > 0) {
                    elBestAmt.innerHTML = `<span class="text-green">${fmt(maxWinStreakAmt)} ${pctSpan(maxWinStreakAmt)}</span>`;

                    // If "Richest" streak is significantly different (different amount), show it
                    if (maxWinStreakVal > maxWinStreakAmt) {
                        // Append info
                        elBestAmt.innerHTML += `
                            <div style="margin-top:6px; border-top:1px dashed #334155; padding-top:4px;">
                                <div style="font-size:0.7em; font-weight:bold; color:#4ade80;">Highest: ${maxWinStreakValCount} Trades</div>
                                <div class="text-green" style="font-weight:700;">${fmt(maxWinStreakVal)}</div>
                                <div style="font-size:0.7em; color:#4ade80; opacity:0.8;">${maxWinStreakValRange}</div>
                            </div>
                         `;
                    }
                } else {
                    elBestAmt.textContent = '--';
                }
                elBestStr.innerHTML = html;
            }

            const elWorstStr = document.getElementById('maxLoseStreak');
            const elWorstDate = document.getElementById('maxLoseStreakDate');
            const elWorstAmt = document.getElementById('maxLoseStreakAmount');

            if (elWorstStr) {
                // Longest Streak
                let html = `<div>${maxLoseStreak} <span style="font-size:0.5em; opacity:0.7;">Trades</span></div>`;
                elWorstDate.textContent = maxLoseStreak > 0 ? maxLoseRange : '(-)';

                if (maxLoseStreak > 0) {
                    elWorstAmt.innerHTML = `<span class="text-red">${fmt(maxLoseStreakAmt)} ${pctSpan(maxLoseStreakAmt)}</span>`;

                    // If "Costliest" streak is worse (more negative) than Longest Streak's amount
                    if (maxLoseStreakVal < maxLoseStreakAmt) {
                        elWorstAmt.innerHTML += `
                            <div style="margin-top:8px; border-top:1px dashed #334155; padding-top:4px;">
                                <div style="font-size:0.7em; opacity:0.8; color:#fca5a5;">Worst Value: ${maxLoseStreakValCount} Trades</div>
                                <div class="text-red">${fmt(maxLoseStreakVal)}</div>
                                <div style="font-size:0.7em; opacity:0.6;">${maxLoseStreakValRange}</div>
                            </div>
                           `;
                    } else {
                        // Even if they are the SAME, user specific request: "give date also".
                        // The 'maxLoseRange' is already displayed above.
                        // But to be super explicit since they asked:
                        // We can just leave it as is, or add a tooltip?
                        // Let's assume the user was confused because of previous mismatch.
                        // But if they asked specifically "date also in same box", 
                        // maybe they want the date NEXT to the amount?
                        // I'll add the date next to the amount if it's the financial worst too.
                    }
                } else {
                    elWorstAmt.textContent = '--';
                }
                elWorstStr.innerHTML = html;
            }

            // Render Charts & Tables
            // Render Charts & Tables
            renderEquityCurve(trades);
            renderTradeList(trades);
            updateView(trades);
        }

        function formatDate(isoStr) {
            // YYYY-MM-DD -> DD-MM
            if (!isoStr) return '';
            const parts = isoStr.split('-');
            return `${parts[2]}-${parts[1]}`; // DD-MM
        }

        function setText(id, txt) {
            const el = document.getElementById(id);
            if (el) el.textContent = txt;
        }

        // --- Library Logic ---
        function saveToLibrary() {
            const name = document.getElementById('portfolioNameInput').value.trim();
            if (!name) return alert("Enter name");
            if (parsedTrades.length === 0) return alert("No data");

            const lib = JSON.parse(localStorage.getItem('portfolioLibrary') || '{}');
            const now = new Date().toISOString();

            let created = now;
            // Preserve created date if overwriting
            if (lib[name] && lib[name].created) {
                created = lib[name].created;
            } else if (lib[name] && lib[name].date) {
                // Migration support
                created = lib[name].date;
            }

            // Capture current multipliers/caps/slippage
            const inputs = document.querySelectorAll('#fileControlsList input.chip-input:not(.cap-input):not(.slip-input)');
            const multipliers = {};
            const capitals = {};
            const slippage = {};

            inputs.forEach(inp => {
                multipliers[inp.getAttribute('data-filename')] = inp.value;
            });

            document.querySelectorAll('#fileControlsList input.cap-input').forEach(inp => {
                capitals[inp.getAttribute('data-filename')] = inp.value;
            });

            document.querySelectorAll('#fileControlsList input.slip-input').forEach(inp => {
                slippage[inp.getAttribute('data-filename')] = inp.value;
            });

            // Capture Date Filters
            const filters = {
                start: document.getElementById('startDateInput').value,
                end: document.getElementById('endDateInput').value
            };

            lib[name] = {
                created: created,
                modified: now,
                trades: parsedTrades,
                multipliers: multipliers,
                capitals: capitals,       // Save Capitals
                slippage: slippage,       // Save Slippage
                filters: filters
            };

            localStorage.setItem('portfolioLibrary', JSON.stringify(lib));
            renderLibraryList();
            document.getElementById('portfolioNameInput').value = '';
            alert("Saved!");
        }

        function renderLibraryList() {
            const list = document.getElementById('portfolioList');
            const lib = JSON.parse(localStorage.getItem('portfolioLibrary') || '{}');

            if (Object.keys(lib).length === 0) {
                list.innerHTML = '<div style="color:#64748b; font-size:0.9em; text-align:center; padding:10px;">No saved portfolios</div>';
                return;
            }

            list.innerHTML = Object.keys(lib).sort().map(name => {
                const item = lib[name];
                // Fallbacks for migration
                const created = item.created || item.date || new Date().toISOString();
                const modified = item.modified || item.date || new Date().toISOString();

                const dateFmt = (d) => {
                    if (!d) return '-';
                    const date = new Date(d);
                    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                };

                return `
                <li style="display:flex; justify-content:space-between; align-items:center; padding:10px; background:#1e293b; margin-bottom:6px; border-radius:6px; border:1px solid #334155;">
                    <div style="flex:1; cursor:pointer;" onclick="loadLib('${name}')">
                        <div style="color:#f8fafc; font-weight:600; font-size:0.95em;">${name}</div>
                        <div style="font-size:0.75em; color:#94a3b8; margin-top:2px;">
                            <span style="margin-right:8px;">Created: ${dateFmt(created)}</span>
                            <span>Mod: ${dateFmt(modified)}</span>
                        </div>
                    </div>
                    <button onclick="delLib('${name}')" title="Delete Portfolio" style="background:none; border:none; color:#ef4444; cursor:pointer; padding:4px; display:flex; align-items:center;">
                        <!-- Trash Icon SVG -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                        </svg>
                    </button>
                </li>
            `;
            }).join('');
        }

        window.loadLib = (name) => {
            const lib = JSON.parse(localStorage.getItem('portfolioLibrary') || '{}');
            if (lib[name]) {
                parsedTrades = lib[name].trades;
                // Update Title to show open portfolio
                document.getElementById('reportTitle').textContent = `FiFto Backtest report - ${name}`;

                // Extract unique files to render controls (and show Date Filter/Multipliers)
                const uniqueFiles = [...new Set(parsedTrades.map(t => t.sourceFile).filter(Boolean))];
                const savedMultipliers = lib[name].multipliers || {};
                const savedCapitals = lib[name].capitals || {};
                const savedSlippage = lib[name].slippage || {};
                renderFileControls(uniqueFiles, savedMultipliers, savedCapitals, savedSlippage);

                // Restore Date Filters
                const filters = lib[name].filters || {};
                document.getElementById('startDateInput').value = filters.start || '';
                document.getElementById('endDateInput').value = filters.end || '';

                // Apply Multipliers/Slippage Logic -> Then Render
                updateMultipliers();
            }
        }

        window.delLib = (name) => {
            const lib = JSON.parse(localStorage.getItem('portfolioLibrary') || '{}');
            delete lib[name];
            localStorage.setItem('portfolioLibrary', JSON.stringify(lib));
            renderLibraryList();
        };

        function exportPortfolio() {
            const dataStr = JSON.stringify(parsedTrades, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `portfolio_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // --- Chart/Table Logic ---
        let equityChart = null;
        // barChart is declared elsewhere
        let pieWinChart = null;
        let pieFileChart = null;
        function renderPieCharts(trades) {
            // 1. Win/Loss Pie
            const ctxWL = document.getElementById('pieWinLoss').getContext('2d');
            if (pieWinChart) pieWinChart.destroy();

            let wins = 0, losses = 0;
            trades.forEach(t => { if (t.pnl >= 0) wins++; else losses++; });

            pieWinChart = new Chart(ctxWL, {
                type: 'doughnut',
                data: {
                    labels: ['Wins', 'Losses'],
                    datasets: [{
                        data: [wins, losses],
                        backgroundColor: ['#10b981', '#ef4444'],
                        borderColor: '#0f172a',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom', labels: { color: '#94a3b8' } }
                    }
                }
            });

            // 2. File Distribution Pie
            const ctxFD = document.getElementById('pieFileDist').getContext('2d');
            if (pieFileChart) pieFileChart.destroy();

            const fileCounts = {};
            trades.forEach(t => {
                const f = t.sourceFile || 'Unknown';
                fileCounts[f] = (fileCounts[f] || 0) + 1;
            });

            const labels = Object.keys(fileCounts);
            const data = Object.values(fileCounts);
            // Palette
            const palette = ['#3b82f6', '#8b5cf6', '#ec4899', '#f59e0b', '#10b981', '#6366f1', '#14b8a6', '#f97316'];
            const apiColors = labels.map((_, i) => palette[i % palette.length]);

            pieFileChart = new Chart(ctxFD, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: apiColors,
                        borderColor: '#0f172a',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom', labels: { color: '#94a3b8', boxWidth: 12 } }
                    }
                }
            });
        }

        function renderEquityCurve(trades) {
            const ctx = document.getElementById('equityChart').getContext('2d');
            if (equityChart) equityChart.destroy();

            // Check View Mode
            const modeEl = document.querySelector('input[name="equityView"]:checked');
            const mode = modeEl ? modeEl.value : 'daily';

            let labels = [];
            let equityData = [];
            let pnlData = [];

            // For coloring bars
            let barColors = [];

            if (mode === 'daily') {
                let run = 0;
                labels = trades.map(t => t.dateStr);
                pnlData = trades.map(t => t.pnl);
                equityData = trades.map(t => { run += t.pnl; return run; });
                barColors = trades.map(t => t.pnl >= 0 ? '#22c55e' : '#ef4444');
            } else {
                // Monthly Aggregation
                const monthlyMap = {};
                trades.forEach(t => {
                    if (!monthlyMap[t.month]) monthlyMap[t.month] = 0;
                    monthlyMap[t.month] += t.pnl;
                });

                const months = Object.keys(monthlyMap).sort();
                labels = months;
                let run = 0;
                months.forEach(m => {
                    const p = monthlyMap[m];
                    run += p; // equity is cumulative
                    equityData.push(run);
                    pnlData.push(p);
                    barColors.push(p >= 0 ? '#22c55e' : '#ef4444');
                });
            }

            equityChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Equity',
                            data: equityData,
                            borderColor: '#22d3ee', // Cyan/Teal like TradingView
                            backgroundColor: 'rgba(34, 211, 238, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 4,
                            yAxisID: 'y',
                            order: 1
                        },
                        {
                            type: 'bar',
                            label: 'P&L',
                            data: pnlData,
                            backgroundColor: barColors,
                            barPercentage: 0.6,
                            categoryPercentage: 0.8,
                            yAxisID: 'y1',
                            order: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(15, 23, 42, 0.95)',
                            titleColor: '#e2e8f0',
                            bodyColor: '#e2e8f0',
                            borderColor: '#334155',
                            borderWidth: 1,
                            padding: 10,
                            callbacks: {
                                label: function (context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(context.parsed.y);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            ticks: {
                                display: true,
                                color: '#94a3b8',
                                maxTicksLimit: 12
                            },
                            border: {
                                display: true,
                                color: '#cbd5e1'
                            },
                            grid: {
                                display: false,
                                drawOnChartArea: false
                            }
                        },
                        y: {
                            type: 'linear', // Explicitly linear
                            display: true,
                            position: 'right', // Put equity axis on right? Or Leave Left? User didn't specify. Standard is Right for overlay? Let's stick to Left for now or revert to standard.
                            // User's image had axis on Left.
                            position: 'left',
                            stack: false, // disable stacking for overlay
                            stackWeight: null,
                            border: { display: true, color: '#cbd5e1' },
                            grid: { color: '#334155', borderColor: '#cbd5e1' },
                            ticks: { color: '#94a3b8' }
                        },
                        y1: {
                            type: 'linear',
                            display: false, // Hide axis
                            position: 'left',
                            stack: false,
                            stackWeight: null,
                            grid: { display: false },
                            // Force bars to bottom 15%
                            min: (ctx) => {
                                const vals = ctx.chart.data.datasets[1].data;
                                if (!vals || vals.length === 0) return 0;
                                const min = Math.min(...vals);
                                return min;
                            },
                            max: (ctx) => {
                                const vals = ctx.chart.data.datasets[1].data;
                                if (!vals || vals.length === 0) return 100;
                                const max = Math.max(...vals);
                                const min = Math.min(...vals);
                                const range = max - min || 1;
                                return max + (range * 5); // Empty space on top
                            }
                        }
                    }
                }
            });
        }

        let barChart = null;
        function toggleStreakDetails(rowID) {
            const el = document.getElementById('details-' + rowID);
            const icon = document.getElementById('icon-' + rowID);
            if (el) {
                const isHidden = el.style.display === 'none';
                el.style.display = isHidden ? 'table-row' : 'none';
                if (icon) icon.innerHTML = isHidden ? '&#9660;' : '&#9654;'; // Down arrow vs Right arrow
            }
        }

        // --- STREAK ANALYSIS LOGIC ---
        function renderStreakAnalysis(trades) {
            const winStreaks = {}; // Map<Length, {count, totalPnl, instances: [{pnl, start, end, trades: []}]}>
            const lossStreaks = {};

            if (!trades || trades.length === 0) {
                const elWin = document.getElementById('winStreakTableBody');
                const elLoss = document.getElementById('lossStreakTableBody');
                if (elWin) elWin.innerHTML = '<tr><td colspan="7" style="text-align:center; padding:20px;">No Data</td></tr>';
                if (elLoss) elLoss.innerHTML = '<tr><td colspan="7" style="text-align:center; padding:20px;">No Data</td></tr>';
                return;
            }

            // Identify Streaks
            let currentStreak = 0; // Positive = Win, Negative = Loss
            let currentPnl = 0;
            let currentTrades = []; // Track trades in current streak

            const addStreak = (len, pnl, isWin, tradeList) => {
                const target = isWin ? winStreaks : lossStreaks;
                if (!target[len]) target[len] = { count: 0, totalPnl: 0, amounts: [], instances: [] };

                target[len].count++;
                target[len].totalPnl += pnl;
                target[len].amounts.push(pnl);

                // Store Instance Details
                const start = tradeList.length > 0 ? tradeList[0].daily : '-';
                const end = tradeList.length > 0 ? tradeList[tradeList.length - 1].daily : '-';
                target[len].instances.push({
                    pnl: pnl,
                    startDate: start,
                    endDate: end,
                    trades: [...tradeList] // Copy
                });
            };

            for (let i = 0; i < trades.length; i++) {
                const t = trades[i];
                const isWin = t.pnl > 0;

                if (isWin) {
                    if (currentStreak > 0) {
                        currentStreak++;
                        currentPnl += t.pnl;
                        currentTrades.push(t);
                    } else {
                        if (currentStreak < 0) {
                            addStreak(Math.abs(currentStreak), currentPnl, false, currentTrades);
                        }
                        currentStreak = 1;
                        currentPnl = t.pnl;
                        currentTrades = [t];
                    }
                } else {
                    if (currentStreak < 0) {
                        currentStreak--;
                        currentPnl += t.pnl;
                        currentTrades.push(t);
                    } else {
                        if (currentStreak > 0) {
                            addStreak(currentStreak, currentPnl, true, currentTrades);
                        }
                        currentStreak = -1;
                        currentPnl = t.pnl;
                        currentTrades = [t];
                    }
                }
            }
            // Capture final streak
            if (currentStreak > 0) {
                addStreak(currentStreak, currentPnl, true, currentTrades);
            } else if (currentStreak < 0) {
                addStreak(Math.abs(currentStreak), currentPnl, false, currentTrades);
            }

            // Calc Totals for Probability
            const calcTotal = (map) => Object.values(map).reduce((sum, item) => sum + item.count, 0);
            const totalWinStreaks = calcTotal(winStreaks);
            const totalLossStreaks = calcTotal(lossStreaks);

            // Render Function
            const renderRows = (dataMap, targetId, isWinTable, totalStreaks) => {
                const el = document.getElementById(targetId);
                if (!el) return;

                // Find max length to iterate 1..Max
                const existingLengths = Object.keys(dataMap).map(Number);
                const maxLen = existingLengths.length > 0 ? Math.max(...existingLengths) : 0;

                if (maxLen === 0) {
                    el.innerHTML = '<tr><td colspan="7" style="text-align:center; padding:20px;">No Data</td></tr>';
                    return;
                }

                let html = '';
                for (let len = 1; len <= maxLen; len++) {
                    const info = dataMap[len] || { count: 0, totalPnl: 0, amounts: [], instances: [] };

                    // Hide if count is zero (User Request)
                    if (info.count === 0) continue;

                    const avg = info.count ? info.totalPnl / info.count : 0;
                    const color = isWinTable ? 'text-green' : 'text-red';
                    const prob = totalStreaks > 0 ? ((info.count / totalStreaks) * 100).toFixed(1) + '%' : '0%';

                    // Calc Min/Max
                    let minVal = 0;
                    let maxVal = 0;
                    if (info.count > 0) {
                        minVal = Math.min(...info.amounts);
                        maxVal = Math.max(...info.amounts);
                    }

                    const rowID = `streak-${isWinTable ? 'win' : 'loss'}-${len}`;
                    const hasData = info.count > 0;

                    html += `<tr class="clickable-row" ${hasData ? `onclick="toggleStreakDetails('${rowID}')"` : ''} style="border-bottom:1px solid #334155;">
                        <td style="padding:10px 15px; color:#e2e8f0; display:flex; align-items:center; gap:8px;">
                            ${hasData ? `<span id="icon-${rowID}" style="font-size:0.8em; width:10px;">&#9654;</span>` : ''} 
                            ${len} in a row
                        </td>
                        <td style="padding:10px 15px; color:#e2e8f0;">${info.count} Times</td>
                        <td style="padding:10px 15px; color:#94a3b8;">${prob}</td>
                        <td style="padding:10px 15px;" class="${color}">${fmt(info.totalPnl)}</td>
                        <td style="padding:10px 15px;" class="${color}">${fmt(avg)}</td>
                        <td style="padding:10px 15px;" class="${color}">${info.count ? fmt(maxVal) : '-'}</td>
                        <td style="padding:10px 15px;" class="${color}">${info.count ? fmt(minVal) : '-'}</td>
                    </tr>`;

                    // Details Row (Hidden)
                    if (hasData) {
                        html += `<tr id="details-${rowID}" style="display:none; background:#0f172a;">
                            <td colspan="7" style="padding:0;">
                                <div style="padding:10px 20px; border-left:4px solid var(--accent-color);">
                                    <table style="width:100%; font-size:0.85em;">
                                        <thead>
                                            <tr style="text-align:left; color:#94a3b8; border-bottom:1px solid #334155;">
                                                <th style="padding:5px;">Date Range</th>
                                                <th style="padding:5px;">Total P&L</th>
                                                <th style="padding:5px;">Trades</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${info.instances.map(inst => `
                                                <tr style="border-bottom:1px solid rgba(255,255,255,0.05);">
                                                    <td style="padding:6px; color:#cbd5e1; vertical-align:top;">${formatDate(inst.startDate)} to ${formatDate(inst.endDate)}</td>
                                                    <td style="padding:6px; vertical-align:top;" class="${inst.pnl >= 0 ? 'text-green' : 'text-red'}">${fmt(inst.pnl)}</td>
                                                    <td style="padding:6px; color:#94a3b8;">
                                                        <div style="margin-bottom:4px;">${inst.trades.length} Trades</div>
                                                        <!-- Sub-division: Trade List -->
                                                        <div style="font-size:0.9em; background:rgba(0,0,0,0.2); padding:4px; border-radius:4px;">
                                                            ${inst.trades.map((t, idx) => `
                                                                <div style="display:flex; justify-content:space-between; border-bottom:1px dashed #334155; padding:2px 0;">
                                                                    <span style="opacity:0.7;">${idx + 1}. ${formatDate(t.daily)}</span>
                                                                    <span class="${t.pnl >= 0 ? 'text-green' : 'text-red'}">${fmt(t.pnl)}</span>
                                                                </div>
                                                            `).join('')}
                                                        </div>
                                                    </td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                </div>
                            </td>
                        </tr>`;
                    }
                }
                el.innerHTML = html || '<tr><td colspan="7" style="text-align:center; padding:10px;">No Streaks</td></tr>';
            };

            renderRows(winStreaks, 'winStreakTableBody', true, totalWinStreaks);
            renderRows(lossStreaks, 'lossStreakTableBody', false, totalLossStreaks);
        }

        function updateView(filteredData) {
            const tradesToUse = filteredData || parsedTrades;
            // if (!tradesToUse.length) return; // Allow rendering empty to clear view
            const mode = document.querySelector('input[name="chartView"]:checked').value;

            // Aggregate
            const map = {};
            // We need order for DD/RU, so process sorted trades.
            // Trades are already sorted by time in calculateAndRender.
            tradesToUse.forEach(t => {
                const k = mode === 'monthly' ? t.month : t.daily;
                if (!map[k]) {
                    map[k] = {
                        label: k,
                        pnl: 0,
                        count: 0,
                        wins: 0,
                        // Per-period DD/RU tracking
                        running: 0,
                        peak: 0,
                        maxDD: 0,
                        trough: 0,
                        maxRunUp: 0,
                        files: new Set()
                    };
                }
                const m = map[k];
                m.pnl += t.pnl;
                m.count++;
                if (t.pnl > 0) m.wins++;
                if (t.sourceFile) m.files.add(t.sourceFile); // Track main files

                // Calc DD/RU within this period
                m.running += t.pnl;

                // DD (Local)
                if (m.running > m.peak) m.peak = m.running;
                const dd = m.running - m.peak;
                if (dd < m.maxDD) m.maxDD = dd;

                // RU (Local)
                if (m.running < m.trough) m.trough = m.running;
                const ru = m.running - m.trough;
                if (ru > m.maxRunUp) m.maxRunUp = ru;

                // Track File Data Separately
                if (t.fileRunUp !== undefined) {
                    if (m.fileRunUpTotal === undefined) m.fileRunUpTotal = 0;
                    m.fileRunUpTotal += t.fileRunUp;
                }
                if (t.fileDrawdown !== undefined) {
                    if (m.fileDrawdownMax === undefined) m.fileDrawdownMax = 0; // usually negative/zero
                    if (t.fileDrawdown < m.fileDrawdownMax) m.fileDrawdownMax = t.fileDrawdown;
                }

                // Store trades for deeper drilling (Daily breakdown within Month)
                if (!m.dailyBreakdown) m.dailyBreakdown = {};
                if (!m.dailyBreakdown[t.daily]) {
                    m.dailyBreakdown[t.daily] = { pnl: 0, count: 0, wins: 0, maxDD: 0, maxRunUp: 0, running: 0, peak: 0, trough: 0, files: new Set() };
                }
                const day = m.dailyBreakdown[t.daily];
                day.pnl += t.pnl;
                day.count++;
                if (t.pnl > 0) day.wins++;
                if (t.sourceFile) day.files.add(t.sourceFile); // Add File Name

                // Track Daily Max DD/RunUp (using Trade values or approximation)
                if (t.fileRunUp > day.maxRunUp) day.maxRunUp = t.fileRunUp;
                if (t.fileDrawdown < day.maxDD) day.maxDD = t.fileDrawdown;

                // Simple Daily Aggregation for nested view
                // Note: Drawdown/Runup here is intra-day if multiple trades, or just sum?
                // User asked for "Daily Wise". Usually just P&L.

                // --- Level 4: File Breakdown Logic ---
                if (!day.fileStats) day.fileStats = {};
                const fName = t.sourceFile || 'Unknown';
                if (!day.fileStats[fName]) {
                    day.fileStats[fName] = {
                        pnl: 0, count: 0, wins: 0, maxRunUp: 0, maxDD: 0,
                        files: new Set([fName]),
                        trades: [] // Store raw trades for display
                    };
                }
                const fStat = day.fileStats[fName];
                fStat.pnl += t.pnl;
                fStat.count++;
                if (t.pnl > 0) fStat.wins++;
                if (t.fileRunUp > fStat.maxRunUp) fStat.maxRunUp = t.fileRunUp;
                if (t.fileDrawdown < fStat.maxDD) fStat.maxDD = t.fileDrawdown;
                fStat.trades.push(t); // Store trade

            });



            const data = Object.keys(map).sort().map(k => {
                const m = map[k];
                // Apply Overrides
                if (m.fileRunUpTotal !== undefined) m.maxRunUp = m.fileRunUpTotal;
                if (m.fileDrawdownMax !== undefined) m.maxDD = m.fileDrawdownMax;
                return m;
            });

            renderTable(data);
            renderBarChart(data);
            renderFileBreakdown(tradesToUse); // New dynamic table
            renderPieCharts(tradesToUse); // New Pie Charts
            renderCoincidentTable(tradesToUse); // New separate table

            document.getElementById('periodHeader').textContent = mode === 'monthly' ? 'Month' : 'Date';
        }

        function toggleDate(dateID) {
            const rows = document.querySelectorAll(`.date-row-${dateID}`);
            const icon = document.getElementById(`icon-date-${dateID}`);
            let requestShow = false;

            if (rows.length > 0 && rows[0].style.display === 'none') {
                requestShow = true;
            }

            rows.forEach(r => {
                r.style.display = requestShow ? 'table-row' : 'none';

                // If hiding Date row, also hide any open Trade rows under it (Cleanup)
                if (!requestShow) {
                    // This is harder because we don't know the exact IDs of all children here easily.
                    // But typically if we hide the parent, the children just disappear visually.
                    // However, if we re-open, we might want them to stay closed?
                    // No, let's keep it simple.
                }
            });

            if (icon) icon.innerHTML = requestShow ? '&#9660;' : '&#9654;';
        }

        function toggleTradeDetails(fileRowID) {
            const rows = document.querySelectorAll(`.trade-row-${fileRowID}`);
            const icon = document.getElementById(`icon-file-${fileRowID}`);
            let requestShow = false;

            if (rows.length > 0 && rows[0].style.display === 'none') {
                requestShow = true;
            }

            rows.forEach(r => {
                r.style.display = requestShow ? 'table-row' : 'none';
            });

            if (icon) icon.innerHTML = requestShow ? '&#9660;' : '&#9654;';
        }

        function renderFileBreakdown(trades) {
            // 1. Identify all unique files and months
            const files = new Set();
            const months = new Set();
            const pivot = {}; // { 'YYYY-MM': { total: 0, 'file1': 0, ... } }

            trades.forEach(t => {
                const fName = t.sourceFile || 'Unknown';
                files.add(fName);

                // Always group by Month for this table, regardless of chart view
                const m = t.month || 'Unknown';
                months.add(m);

                if (!pivot[m]) pivot[m] = { total: 0 };
                if (!pivot[m][fName]) pivot[m][fName] = 0;

                pivot[m][fName] += t.pnl;
                pivot[m].total += t.pnl;
            });

            const sortedMonths = Array.from(months).sort(); // Oldest first? or Newest? 
            // Usually Monthly reports are chronologically sorted. "sort()" does ISO string => Oldest First.

            const sortedFiles = Array.from(files).sort();

            // 2. Render Header
            const thead = document.getElementById('fileBreakdownHead');
            const tbody = document.getElementById('fileBreakdownBody');
            if (!thead || !tbody) return;

            // Header Row
            let headerHTML = `<tr><th>Period</th><th>Total P&L</th>`;
            sortedFiles.forEach(f => {
                headerHTML += `<th>${f}</th>`;
            });
            headerHTML += `</tr>`;
            thead.innerHTML = headerHTML;

            // 3. Render Body
            // Group by Year first
            const years = {};
            sortedMonths.forEach(m => {
                const yr = m.substring(0, 4);
                if (!years[yr]) years[yr] = { months: [], total: 0, files: {} };
                years[yr].months.push(m);

                // Aggregate Year Totals
                const rowMove = pivot[m];
                years[yr].total += rowMove.total;
                sortedFiles.forEach(f => {
                    if (!years[yr].files[f]) years[yr].files[f] = 0;
                    years[yr].files[f] += (rowMove[f] || 0);
                });
            });

            // GLOBAL FORMATTER IS visible here
            const fmt = fmtMoney;

            let bodyHTML = '';
            Object.keys(years).sort().forEach(yr => {
                const yData = years[yr];
                const yrId = `fb-yr-${yr}`;
                const totalClass = yData.total >= 0 ? 'text-green' : 'text-red';

                // Year Row (Accordion Header)
                bodyHTML += `<tr style="background:var(--surface-color); font-weight:700; cursor:pointer; border-bottom:2px solid var(--border-color);" onclick="toggleFileBreakdown('${yr}')">
                     <td style="display:flex; align-items:center; gap:8px;">
                         <span id="icon-${yrId}">&#9654;</span> ${yr}
                     </td>
                     <td class="${totalClass}">${fmt(yData.total)}</td>`;

                sortedFiles.forEach(f => {
                    const val = yData.files[f] || 0;
                    const cls = val >= 0 ? 'text-green' : 'text-red';
                    bodyHTML += `<td class="${cls}">${fmt(val)}</td>`;
                });
                bodyHTML += `</tr>`;

                // Month Rows (Hidden Children)
                yData.months.sort().forEach(m => {
                    const rowData = pivot[m];
                    const mTotalClass = rowData.total >= 0 ? 'text-green' : 'text-red';

                    bodyHTML += `<tr class="${yrId}" style="display:none; background:#0f172a;">
                          <td style="padding-left:30px; border-left:2px solid var(--border-color);">${m}</td>
                          <td class="${mTotalClass}" style="font-weight:600;">${fmt(rowData.total)}</td>`;

                    sortedFiles.forEach(f => {
                        const val = rowData[f] || 0;
                        const cls = val >= 0 ? 'text-green' : 'text-red';
                        bodyHTML += `<td class="${cls}">${fmt(val)}</td>`;
                    });
                    bodyHTML += `</tr>`;
                });
            });

            tbody.innerHTML = bodyHTML;
        }

        function toggleFileBreakdown(yr) {
            const yrId = `fb-yr-${yr}`;
            const rows = document.querySelectorAll(`.${yrId}`);
            const icon = document.getElementById(`icon-${yrId}`);
            let requestShow = false;

            if (rows.length > 0 && rows[0].style.display === 'none') {
                requestShow = true;
            }

            rows.forEach(r => {
                r.style.display = requestShow ? 'table-row' : 'none';
            });

            if (icon) icon.innerHTML = requestShow ? '&#9660;' : '&#9654;';
        }

        function renderBarChart(data) {
            const ctx = document.getElementById('monthlyChart').getContext('2d');
            if (barChart) barChart.destroy();

            barChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(d => d.label),
                    datasets: [{
                        data: data.map(d => d.pnl),
                        backgroundColor: data.map(d => d.pnl >= 0 ? '#10b981' : '#ef4444'),
                        borderRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { ticks: { color: '#94a3b8' }, grid: { display: false } },
                        y: { grid: { color: '#334155' }, ticks: { color: '#94a3b8' } }
                    }
                }
            });
        }

        let timeChart = null;
        function renderTimeAnalysis(trades) {
            // Get Bucket Size
            const bucketSize = parseInt(document.querySelector('input[name="timeGrouping"]:checked').value);

            // Bucket Logic
            const buckets = {};

            trades.forEach(t => {
                const totalMinutes = t.hour * 60 + t.minute;
                const slotIndex = Math.floor(totalMinutes / bucketSize);
                const slotStartMin = slotIndex * bucketSize;

                const h = Math.floor(slotStartMin / 60);
                const m = slotStartMin % 60;
                const label = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;

                if (!buckets[label]) buckets[label] = {
                    label,
                    pnl: 0,
                    count: 0,
                    wins: 0,
                    losses: 0,
                    sortKey: slotStartMin
                };

                buckets[label].pnl += t.pnl;
                buckets[label].count++;
                if (t.pnl > 0) buckets[label].wins++;
                else buckets[label].losses++;
            });

            const sortedBuckets = Object.values(buckets).sort((a, b) => a.sortKey - b.sortKey);

            // Render Chart
            const ctx = document.getElementById('timeChart').getContext('2d');
            if (timeChart) timeChart.destroy();

            timeChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sortedBuckets.map(b => b.label),
                    datasets: [{
                        label: 'Net P&L',
                        data: sortedBuckets.map(b => b.pnl),
                        backgroundColor: sortedBuckets.map(b => b.pnl >= 0 ? '#10b981' : '#ef4444'),
                        borderRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { ticks: { color: '#94a3b8' }, grid: { display: false } },
                        y: { grid: { color: '#334155' }, ticks: { color: '#94a3b8' } }
                    }
                }
            });

            // Render Table
            const tbody = document.getElementById('timeTableBody');
            const fmt = (v) => new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(v);

            tbody.innerHTML = sortedBuckets.map(b => {
                const winRate = b.count ? ((b.wins / b.count) * 100).toFixed(1) + '%' : '0%';
                return `
                    <tr>
                        <td style="font-weight:bold">${b.label}</td>
                        <td>${b.count}</td>
                        <td class="text-green">${b.wins}</td>
                        <td class="text-red">${b.losses}</td>
                        <td>${winRate}</td>
                        <td class="${b.pnl >= 0 ? 'text-green' : 'text-red'}" style="font-weight:700;">${fmt(b.pnl)}</td>
                    </tr>
                `;
            }).join('');
        }

        let currentAnalysisMode = 'entry'; // 'entry' or 'exit'

        function switchAnalysisMode(mode) {
            currentAnalysisMode = mode;
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-analysis-${mode}`).classList.add('active');
            filterTimeAnalysisTrades(); // Re-render with new mode
        }

        function filterTimeAnalysisTrades() {
            let startStr = document.getElementById('timeAnalysisStart').value;
            let endStr = document.getElementById('timeAnalysisEnd').value;
            const table = document.getElementById('timeTradesTable');
            const tbody = document.getElementById('timeTradesBody');

            if (!startStr && !endStr) {
                alert("Please select a Start Time, End Time, or both.");
                return;
            }

            // Support Single Time Entry (Exact Match)
            if (startStr && !endStr) endStr = startStr;
            if (!startStr && endStr) startStr = endStr;

            // Helper to mins
            const toMins = (str) => {
                const [h, m] = str.split(':').map(Number);
                return h * 60 + m;
            };
            const startMins = toMins(startStr);
            const endMins = toMins(endStr);

            // Filter CURRENT parsedTrades (respecting global date filter too? 
            // User likely expects global date filter to apply, then SUB-filter by time.
            // Let's use the 'parsedTrades' but adhere to hiddenFiles.
            // AND adhere to global Date Filter? 
            // Yes, "Show trades" implies consistent view.

            // Re-apply global date filter logic locally or just use calculateAndRender's input?
            // Actually, best is to filter from 'parsedTrades' but check dates manually here 
            // OR use a cached 'filteredTrades' global? We don't have one.
            // Let's re-implement Date check for safety.

            const globalStartStr = document.getElementById('startDateInput').value;
            const globalEndStr = document.getElementById('endDateInput').value;
            const gStartTs = globalStartStr ? new Date(globalStartStr).getTime() : 0;
            const gEndTs = globalEndStr ? new Date(globalEndStr).setHours(23, 59, 59, 999) : Number.MAX_SAFE_INTEGER;

            const results = parsedTrades.filter(t => {
                if (hiddenFiles.has(t.sourceFile)) return false;
                if (t.timestamp < gStartTs || t.timestamp > gEndTs) return false;

                if (t.hour === undefined) return false;

                let tMins = 0;
                if (currentAnalysisMode === 'entry') {
                    // Use Entry Time
                    tMins = t.hour * 60 + t.minute;
                } else {
                    // Use Exit Time (if captured, otherwise skip or fallback??)
                    // If exit details missing, maybe exclude?
                    if (t.exitHour === undefined) return false;
                    tMins = t.exitHour * 60 + t.exitMinute;
                }

                return tMins >= startMins && tMins <= endMins;
            });

            // Render
            table.style.display = 'table';
            const fmt = (v) => new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(v);

            if (results.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align:center; padding:20px;">No trades found in this time range.</td></tr>';
                return;
            }

            tbody.innerHTML = results.map(t => {
                // Determine values based on MODE
                let displayTime = t.time;
                let displaySignal = t.signalName || '-';
                let displayPrice = t.price || 0; // Default to Entry Price

                if (currentAnalysisMode === 'exit') {
                    displayTime = t.exitTime || '-';
                    displaySignal = t.exitSignal || '-';
                    displayPrice = t.exitPrice || 0;
                } else {
                    // ENTRY MODE FORCE FIX:
                    // Even if data linking failed and we have "Exit Long", showing it in "Entry Analysis" is confusing.
                    // Force the label to match the view's intent.
                    if (displaySignal.toLowerCase().includes('exit')) {
                        displaySignal = displaySignal.replace(/Exit/i, 'Entry').replace(/Close/i, 'Open');
                    }
                }

                return `
                <tr>
                    <td>${t.dateStr.split(' ')[0]}</td> <!-- Show Date Only -->
                    <td>${displayTime}</td>
                    <td style="color:var(--accent-color);">${displaySignal}</td>
                    <td>${fmt(displayPrice)}</td>
                    <td>${t.pnl >= 0 ? 'WIN' : 'LOSS'}</td>
                    <td class="${t.pnl >= 0 ? 'text-green' : 'text-red'}">${fmt(t.pnl)}</td>
                    <td style="font-size:0.8em; opacity:0.7;">${t.sourceFile}</td>
                </tr>`;
            }).join('');
        }

        function renderTable(data) {
            const tbody = document.getElementById('tableBody');
            const fmt = (v) => new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(v);

            // Heuristic to detect Monthly view (Label format YYYY-MM)
            const isMonthly = data.length > 0 && data[0].label.length === 7;

            if (isMonthly) {
                // Group by Year
                const years = {};
                let cum = 0;

                data.forEach(row => {
                    const y = row.label.substring(0, 4);
                    if (!years[y]) years[y] = {
                        year: y,
                        pnl: 0,
                        count: 0,
                        wins: 0,
                        rows: []
                    };
                    years[y].pnl += row.pnl;
                    years[y].count += row.count;
                    years[y].wins += row.wins;
                    years[y].rows.push(row);
                });

                // Render
                let html = '';
                let runningCum = 0;

                Object.keys(years).sort().forEach(y => {
                    const yr = years[y];
                    const winRate = yr.count ? ((yr.wins / yr.count) * 100).toFixed(1) : 0;

                    // Year Header Row
                    // Year Header Row
                    html += `
                <tr style="background:var(--surface-color); font-weight:700; cursor:pointer; border-bottom:2px solid var(--border-color);" onclick="toggleYear('${y}')">
                            <td style="display:flex; align-items:center; gap:8px;">
                                <span id="icon-${y}">&#9654;</span> ${y} 
                                <span style="font-size:0.8em; opacity:0.7; font-weight:400;">(${yr.count} trades)</span>
                            </td>
                            <td class="${yr.pnl >= 0 ? 'text-green' : 'text-red'}">${fmt(yr.pnl)}</td>
                            <td style="opacity:0.5">-</td> 
                            <td>${yr.count}</td>
                            <td class="text-green">${yr.wins}</td>
                            <td class="text-red">${yr.count - yr.wins}</td>
                            <td>${winRate}%</td>
                            <td>-</td>
                            <td>-</td>
                            <td>-</td> <!--File Col-->
                        </tr>
                `;

                    // Month Rows
                    yr.rows.forEach(row => {
                        runningCum += row.pnl;
                        const rowWin = ((row.wins / row.count) * 100).toFixed(1) + '%';
                        const mID = row.label; // YYYY-MM

                        html += `
                <tr class="year-row-${y} clickable-row" style="display:none; background:#0f172a;" onclick="toggleMonth('${mID}')" title="Click to view daily details">
                                <td style="padding-left:30px; font-size:0.95em; color:var(--text-secondary); border-left: 2px solid var(--border-color); display:flex; align-items:center; gap:5px;">
                                    <span id="icon-${mID}" style="font-size:0.8em; width:12px;">&#9654;</span> ${row.label}
                                </td>
                                <td class="${row.pnl >= 0 ? 'text-green' : 'text-red'}">${fmt(row.pnl)}</td>
                                <td class="${runningCum >= 0 ? 'text-green' : 'text-red'}">${fmt(runningCum)}</td>
                                <td>${row.count}</td>
                                <td class="text-green">${row.wins}</td>
                                <td class="text-red">${row.count - row.wins}</td>
                                <td>${rowWin}</td>
                                <td class="text-green">${fmt(row.maxRunUp)}</td>
                                <td class="text-red">${fmt(row.maxDD)}</td>
                                <td>-</td> <!--File Col-->
                            </tr>
                `;

                        // Daily Rows (Level 3)
                        if (row.dailyBreakdown) {
                            let dailyCum = runningCum - row.pnl; // Start from previous month's end

                            Object.keys(row.dailyBreakdown).sort().forEach(dayDate => {
                                const day = row.dailyBreakdown[dayDate];
                                dailyCum += day.pnl;
                                const dWin = ((day.wins / day.count) * 100).toFixed(1) + '%';
                                const filesInfo = Array.from(day.files).join(', '); // Join file names

                                const [y, m, d] = dayDate.split('-');
                                const fmtDate = `${d} - ${m} - ${y} `;
                                const dateID = dayDate; // YYYY-MM-DD
                                const hasFiles = day.fileStats && Object.keys(day.fileStats).length > 0;
                                const expandCursor = hasFiles ? 'cursor:pointer;' : '';

                                html += `
            <tr class="month-row-${mID}" style="display:none; background:#020617; font-size:0.85em; ${expandCursor}" ${hasFiles ? `onclick="toggleDate('${dateID}')"` : ''}>
                                        <td style="padding-left:60px; color:var(--text-secondary); border-left: 2px solid var(--border-color); white-space:nowrap; display:flex; align-items:center; gap:5px;">
                                            ${hasFiles ? `<span id="icon-date-${dateID}" style="font-size:0.8em; width:12px;">&#9654;</span>` : ''} 
                                            ${fmtDate}
                                        </td>
                                        <td class="${day.pnl >= 0 ? 'text-green' : 'text-red'}" style="white-space:nowrap;">${fmt(day.pnl)}</td>
                                        <td class="${dailyCum >= 0 ? 'text-green' : 'text-red'}" style="white-space:nowrap;">${fmt(dailyCum)}</td>
                                        <td>${day.count}</td>
                                        <td class="text-green">${day.wins}</td>
                                        <td class="text-red">${day.count - day.wins}</td>
                                        <td>${dWin}</td>
                                        <td class="text-green" style="white-space:nowrap;">${fmt(day.maxRunUp)}</td>
                                        <td class="text-red" style="white-space:nowrap;">${fmt(day.maxDD)}</td>
                                        <td style="color:var(--text-secondary); font-size:0.9em; white-space:nowrap;">${filesInfo}</td>
                                    </tr>
            `;

                                // Level 4: File Rows
                                if (hasFiles) {
                                    Object.keys(day.fileStats).sort().forEach(fName => {
                                        const fStat = day.fileStats[fName];
                                        const fWin = fStat.count ? ((fStat.wins / fStat.count) * 100).toFixed(1) + '%' : '0%';

                                        // Unique ID for this File Row
                                        const fileRowID = `${dateID}-${fName.replace(/[^a-zA-Z0-9]/g, '')}`;
                                        const hasTrades = fStat.trades && fStat.trades.length > 0;

                                        html += `
            <tr class="date-row-${dateID} clickable-row" style="display:none; background:#000000; font-size:0.8em; border-left: 3px solid var(--accent-color);" ${hasTrades ? `onclick="toggleTradeDetails('${fileRowID}')"` : ''}>
                                                <td style="padding-left:90px; color:#94a3b8; font-style:italic; display:flex; align-items:center; gap:5px;">
                                                    ${hasTrades ? `<span id="icon-file-${fileRowID}" style="font-size:0.8em; width:10px;">&#9654;</span>` : ''}
                                                    ${fName}
                                                </td>
                                                <td class="${fStat.pnl >= 0 ? 'text-green' : 'text-red'}">${fmt(fStat.pnl)}</td>
                                                <td style="opacity:0.3">-</td> 
                                                <td>${fStat.count}</td>
                                                <td class="text-green">${fStat.wins}</td>
                                                <td class="text-red">${fStat.count - fStat.wins}</td>
                                                <td>${fWin}</td>
                                                <td class="text-green">${fmt(fStat.maxRunUp)}</td>
                                                <td class="text-red">${fmt(fStat.maxDD)}</td>
                                                <td style="opacity:0.5">-</td>
                                            </tr>
            `;
                                        // Level 5: Trade Rows (Hidden)
                                        if (hasTrades) {
                                            fStat.trades.forEach(t => {
                                                const timeStr = t.time || '-';
                                                const signal = t.signalName || '-';

                                                html += `
                                            <tr class="trade-row-${fileRowID}" style="display:none; background:#050505; font-size:0.75em; border-left: 4px solid #334155;">
                                                <td style="padding-left:110px; color:#64748b;">
                                                    <span style="margin-right:8px;">${timeStr}</span> 
                                                    <span style="color:var(--accent-color); font-weight:600;">${signal}</span>
                                                    <span style="margin-left:8px; opacity:0.7;">@ ${t.price}</span>
                                                </td>
                                                <td class="${t.pnl >= 0 ? 'text-green' : 'text-red'}">${fmt(t.pnl)}</td>
                                                <td style="opacity:0.2">-</td>
                                                <td style="opacity:0.5">1</td>
                                                <td>${t.pnl >= 0 ? '1' : '0'}</td>
                                                <td>${t.pnl < 0 ? '1' : '0'}</td>
                                                <td>-</td>
                                                <td class="text-green">${fmt(t.fileRunUp || 0)}</td>
                                                <td class="text-red">${fmt(t.fileDrawdown || 0)}</td>
                                                <td style="opacity:0.3">Trade</td>
                                            </tr>`;
                                            });
                                        }
                                    });
                                }
                            });
                        }
                    });
                });
                tbody.innerHTML = html;

            } else {
                // Standard Daily View (Flat)
                let cum = 0;
                tbody.innerHTML = data.map(row => {
                    cum += row.pnl;
                    const winRate = ((row.wins / row.count) * 100).toFixed(1) + '%';
                    const filesInfo = row.files ? Array.from(row.files).join(', ') : '-';
                    return `<tr class="clickable-row">
                        <td>${row.label}</td>
                        <td class="${row.pnl >= 0 ? 'text-green' : 'text-red'}">${fmt(row.pnl)}</td>
                        <td class="${cum >= 0 ? 'text-green' : 'text-red'}">${fmt(cum)}</td>
                        <td>${row.count}</td>
                        <td class="text-green">${row.wins}</td>
                        <td class="text-red">${row.count - row.wins}</td>
                        <td>${winRate}</td>
                        <td class="text-green">${fmt(row.maxRunUp)}</td>
                        <td class="text-red">${fmt(row.maxDD)}</td>
                        <td style="color:var(--text-secondary); font-size:0.9em;">${filesInfo}</td>
                    </tr>`;
                }).join('');
            }
        }

        function renderCoincidentTable(trades) {
            const panel = document.getElementById('coincidentPanel');
            const tbody = document.getElementById('coincidentBody');
            const fmt = (v) => new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(v);

            // Group by Date (YYYY-MM-DD)
            const map = {};
            trades.forEach(t => {
                const date = t.daily; // YYYY-MM-DD
                if (!map[date]) map[date] = { date: date, dateStr: t.dateStr, pnl: 0, files: new Set(), fileDetails: {} };
                const d = map[date];
                d.pnl += t.pnl;

                const fName = t.sourceFile || 'Unknown';
                d.files.add(fName);
                if (!d.fileDetails[fName]) d.fileDetails[fName] = 0;
                d.fileDetails[fName] += t.pnl;
            });

            // Filter for dates with > 1 file
            const coincidence = Object.values(map).filter(d => d.files.size > 1).sort((a, b) => b.date.localeCompare(a.date)); // Newest first

            if (coincidence.length === 0) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';

            // Group by Year > Month
            const years = {};
            coincidence.forEach(d => {
                const y = d.date.substring(0, 4);
                const m = d.date.substring(0, 7); // YYYY-MM

                if (!years[y]) years[y] = { pnl: 0, count: 0, months: {} };
                years[y].pnl += d.pnl;
                years[y].count++;

                if (!years[y].months[m]) years[y].months[m] = { pnl: 0, count: 0, days: [] };
                years[y].months[m].pnl += d.pnl;
                years[y].months[m].count++;
                years[y].months[m].days.push(d);
            });

            // Render Hierarchy
            let html = '';
            Object.keys(years).sort().reverse().forEach(y => {
                const yr = years[y];
                const yrId = `coinc-yr-${y}`;

                // Year Row
                html += `
            <tr style="background:var(--surface-color); font-weight:700; cursor:pointer; border-bottom:2px solid var(--border-color);" onclick="toggleCoincYear('${y}')">
                        <td style="display:flex; align-items:center; gap:8px;">
                            <span id="icon-${yrId}">&#9654;</span> ${y} 
                            <span style="font-size:0.8em; opacity:0.7; font-weight:400;">(${yr.count} coincident days)</span>
                        </td>
                        <td class="${yr.pnl >= 0 ? 'text-green' : 'text-red'}">${fmt(yr.pnl)}</td>
                        <td>-</td>
                        <td>-</td>
                    </tr>
            `;

                // Month Rows
                Object.keys(yr.months).sort().reverse().forEach(m => {
                    const mo = yr.months[m];
                    const moId = `coinc-mo-${m}`; // YYYY-MM

                    html += `
            <tr class="${yrId}" style="display:none; background:#0f172a; cursor:pointer;" onclick="toggleCoincMonth('${m}')">
                            <td style="padding-left:30px; border-left: 2px solid var(--border-color); display:flex; align-items:center; gap:5px;">
                                <span id="icon-${moId}" style="font-size:0.8em; width:12px;">&#9654;</span> ${m}
                                <span style="font-size:0.8em; opacity:0.7;">(${mo.count} days)</span>
                            </td>
                            <td class="${mo.pnl >= 0 ? 'text-green' : 'text-red'}">${fmt(mo.pnl)}</td>
                            <td>-</td>
                            <td>-</td>
                        </tr>
            `;

                    // Day Rows
                    mo.days.forEach(d => {
                        const fileBadges = Object.keys(d.fileDetails).sort().map(f => {
                            const val = d.fileDetails[f];
                            const cls = val >= 0 ? 'text-green' : 'text-red';
                            return `<span style="display:inline-block; background:#1e293b; padding:2px 8px; border-radius:12px; margin-right:6px; font-size:0.85em; border:1px solid #334155;">
            <span style="color:#e2e8f0;">${f}</span>: <span class="${cls}" style="font-weight:600;">${fmt(val)}</span>
                            </span>`;
                        }).join(' ');

                        html += `
            <tr class="${moId} ${yrId}-child" style="display:none; background:#020617;">
                                <td style="padding-left:60px; color:var(--text-secondary); border-left: 2px solid var(--border-color);">${d.dateStr}</td>
                                <td class="${d.pnl >= 0 ? 'text-green' : 'text-red'}" style="font-weight:700;">${fmt(d.pnl)}</td>
                                <td>${d.files.size}</td>
                                <td>${fileBadges}</td>
                            </tr>
            `;
                    });
                });
            });

            tbody.innerHTML = html;
        }

        function toggleCoincYear(y) {
            const yrId = `coinc-yr-${y}`;
            const rows = document.querySelectorAll(`.${yrId}`);
            const icon = document.getElementById(`icon-${yrId}`);
            let show = false;

            // Check if first Month row is hidden
            if (rows.length > 0 && rows[0].style.display === 'none') {
                show = true;
            }

            rows.forEach(r => {
                // Should we show all? Or just Months?
                // Ideally show Month rows. Keep Child (Day) rows hidden unless Month was open?
                // Simpler: Just toggle Month rows. Child rows logic handled by toggleCoincMonth.
                // But wait, if we hide Year, we must hide EVERYTHING under it (Months and Days).

                if (show) {
                    // Only show Month rows directly (not children of months)
                    // My class structure: Month Row has class `yrId`. Day Row has class `moId` AND `yrId - child`.
                    // Wait, Day Row needs to be hidden if Month is NOT expanded.
                    // Let's rely on specific classes.
                    if (!r.classList.contains(`${yrId}-child`)) {
                        r.style.display = 'table-row';
                    }
                } else {
                    r.style.display = 'none'; // Hide month rows
                    // Also hide children?
                    // Day rows have class `${ moId } `. 
                    // This selector `.${ yrId } ` selects Month rows.
                    // I need to select children too?
                    // Or add `${ yrId } ` class to children too? NO.
                }
            });

            // If Hiding, we must also hide any open children (Day rows).
            if (!show) {
                const children = document.querySelectorAll(`.${yrId}-child`);
                children.forEach(c => c.style.display = 'none');
                // Reset Month icons? Optional.
            }

            if (icon) icon.innerHTML = show ? '&#9660;' : '&#9654;';
        }

        function toggleCoincMonth(m) {
            const moId = `coinc-mo-${m}`;
            const rows = document.querySelectorAll(`.${moId}`); // These are Day rows
            const icon = document.getElementById(`icon-${moId}`);
            let show = false;

            if (rows.length > 0 && rows[0].style.display === 'none') {
                show = true;
            }

            rows.forEach(r => {
                r.style.display = show ? 'table-row' : 'none';
            });

            if (icon) icon.innerHTML = show ? '&#9660;' : '&#9654;';
        }

        function toggleYear(val) {
            const rows = document.querySelectorAll(`.year-row-${val}`);
            const icon = document.getElementById(`icon-${val}`);
            let requestShow = false;

            // Check first row state
            if (rows.length > 0 && rows[0].style.display === 'none') {
                requestShow = true;
            }

            rows.forEach(r => {
                r.style.display = requestShow ? 'table-row' : 'none';
                // If hiding year, also hide any open months inside it? 
                // Creating a cleaner UX: If collapsing year, just collapse year rows. The nested month rows will stay as is or hidden?
                // The current structure has Month rows as siblings to Year, and Daily as Siblings to Month.
                // It's a flat table visually.

                // If collapsing Year, we should also hide the Daily rows belonging to those months.
                // But simplified: just toggle the direct children (Months).
                // If user re-expands YEAR, the Months appear. If a Month was open, its Daily rows might still be visible? 
                // No, Daily rows are siblings. We need to hide them too if we want full collapse.
                // Let's iterate and hide children too if closing.
                if (!requestShow) {
                    // We are closing Year. Find relevant Month IDs?
                    // Hard to select easily without more complex logic. 
                    // Let's just keep simple toggling. User can close months manually.
                }
            });

            if (icon) icon.innerHTML = requestShow ? '&#9660;' : '&#9654;';
        }

        function toggleMonth(mID) {
            const rows = document.querySelectorAll(`.month-row-${mID}`);
            const icon = document.getElementById(`icon-${mID}`);
            let requestShow = false;

            if (rows.length > 0 && rows[0].style.display === 'none') {
                requestShow = true;
            }

            rows.forEach(r => {
                r.style.display = requestShow ? 'table-row' : 'none';
            });

            if (icon) icon.innerHTML = requestShow ? '&#9660;' : '&#9654;';

            // Prevent event bubbling if row was clickable for filter?
            // I removed filterHistory on Month row to allow Toggle.
            // User asked for "Click month ... daily ... dropbox".
            // So Filter is secondary or removed for Month row?
            // "Show daily wise" implies accordian.
        }

        function renderTradeList(trades) {
            const tbody = document.getElementById('tradeListBody');
            // We need to loop manually or map correctly. 
            // Note: The 'cum' variable in previous code was just summing P&L linearly.
            // But we actually calculated 'cum' inside calculateAndRender properly too or we can just reconstruct.
            // Actually, calculateAndRender didn't store 'cum' on 't'. 
            // Let's recalculate accurately or use t.currentDD / t.currentRU from calculateAndRender.

            const fmt = (v) => new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR' }).format(v);
            let runningPnl = 0;
            let peak = 0;
            let trough = 0;

            const rows = trades.map(t => {
                runningPnl += t.pnl; // Re-calculate cumulative for display

                // Calc Local DD/RU for valid table view consistency
                if (runningPnl > peak) peak = runningPnl;
                const dd = runningPnl - peak;

                if (runningPnl < trough) trough = runningPnl;
                const ru = runningPnl - trough;

                // Priority: File Data > Local Calculation
                const displayDD = (t.fileDrawdown !== undefined) ? t.fileDrawdown : dd;
                const displayRU = (t.fileRunUp !== undefined) ? t.fileRunUp : ru;

                return { ...t, cum: runningPnl, displayDD, displayRU };
            });

            // We want to show Newest First usually? Or Oldest First?
            // Existing code was Oldest first. Let's stick to that or Reverse as preferred.
            // User didn't specify, but history usually implies order.
            // Let's keep original order (Oldest -> Newest) as per chart.

            // Trade Row
            // Trade Row
            document.getElementById('tradeListBody').innerHTML = rows.map(t => {
                const win = t.pnl > 0;
                return `<tr class="clickable-row">
                    <td>${t.dateStr}</td>
                    <td class="${t.pnl >= 0 ? 'text-green' : 'text-red'}">${fmt(t.pnl)}</td>
                    <td class="${t.cum >= 0 ? 'text-green' : 'text-red'}">${fmt(t.cum)}</td>
                    <td>1</td>
                    <td class="text-green">${win ? 1 : 0}</td>
                    <td class="text-red">${win ? 0 : 1}</td>
                    <td>${win ? '100%' : '0%'}</td>
                    <td class="text-green">${fmt(t.displayRU)}</td>
                    <td class="text-red">${fmt(t.displayDD)}</td>
                    <td style="font-size:0.8em; opacity:0.7;">${t.sourceFile || '-'}</td>
                </tr>`;
            }).join('');

            document.getElementById('debugTableBody').innerHTML = trades.slice(-5).map(t => `
            <tr><td>${t.dateStr}</td><td>Exit</td><td>${t.pnl}</td></tr>
                `).join('');
        }

        // Filter Logic
        let currentFilter = null;
        function filterHistory(label) {
            // Determine if label is Month (YYYY-MM) or Date (YYYY-MM-DD) based on mode
            const mode = document.querySelector('input[name="chartView"]:checked').value;

            // Toggle Filter
            if (currentFilter === label) {
                currentFilter = null;
                renderTradeList(parsedTrades); // Reset
                // Optional: visual feedback reset
            } else {
                currentFilter = label;
                const filtered = parsedTrades.filter(t => {
                    return mode === 'monthly' ? t.month === label : t.daily === label;
                });
                renderTradeList(filtered);
                renderStreakAnalysis(filtered); // Update streaks
                // Auto-scroll to History Table
                const tableEl = document.getElementById('tradeListTable');
                if (tableEl) tableEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }

            // Re-render monthly table to show selection? 
            // Maybe just highlight row. For now, simple standard re-render might be overkill or lose selection state if we don't track it.
            // But renderTable is called by updateView.
            // Let's simple alert or scroll? No, just filter.
        }
        function calculateTargetHit() {
            const val = document.getElementById('runupTargetInput').value;
            const resEl = document.getElementById('runupTargetResult');
            const pctEl = document.getElementById('runupTargetPercent');

            if (!val || !parsedTrades.length) {
                resEl.textContent = '-- / --';
                pctEl.textContent = '--%';
                return;
            }

            const target = parseFloat(val);
            if (isNaN(target)) return;

            // Count trades that reached target run-up
            // Priority: fileRunUp > calculated 'ru' (which isn't stored on 't' in parsedTrades usually, but we can re-calc or use what we have)
            // Wait, 'parsedTrades' only has fileRunUp if from file. Local 'ru' is calculated in updateView/calculateAndRender but not persisted to parsedTrades array permanently unless we modify objects.
            // In calculateAndRender, we iterate but don't save 'ru' to the object set efficiently for external access? 
            // Actually, we can just re-calculate local runup if needed: (max profit during trade). 
            // EXCEPT: We don't have intra-trade data locally. We only have 'pnl'.
            // For local data: Max Run Up = Max(0, Pnl) ? No, that's simplified.
            // If we don't have MFE (Max Favorable Excursion), we can't know if a losing trade was up +500 at some point.
            // SO: If fileRunUp is missing, we can arguably only use 'pnl' if > 0 as a "at least reached this" lower bound? 
            // Or just rely on fileRunUp.
            // Let's rely on fileRunUp if present. If not, use Math.max(0, t.pnl).

            const count = parsedTrades.filter(t => {
                let r = t.fileRunUp;
                if (r === undefined) {
                    // Fallback: If trade ended positive, it at least reached that. 
                    // If negative, we don't know (could have been green). 
                    // Assume 0 for neg? Or Pnl for pos.
                    r = t.pnl > 0 ? t.pnl : 0;
                }
                return r >= target;
            }).length;

            const total = parsedTrades.length;
            const pct = ((count / total) * 100).toFixed(1);

            resEl.textContent = `${count} / ${total} Trades`;
            pctEl.textContent = `${pct}% Reached Target`;
        }

        function calculateDrawdownHit() {
            const val = document.getElementById('drawdownTargetInput').value;
            const resEl = document.getElementById('drawdownTargetResult');
            const pctEl = document.getElementById('drawdownTargetPercent');

            if (!val || !parsedTrades.length) {
                resEl.textContent = '-- / --';
                pctEl.textContent = '--%';
                return;
            }

            let target = parseFloat(val);
            if (isNaN(target)) return;

            // Convert to negative if user enters positive (which is expected for "Drawdown of 1000")
            if (target > 0) target = -target;

            // Count trades where Drawdown is DEEPER than target (e.g. <= -1000)
            const count = parsedTrades.filter(t => {
                let d = t.fileDrawdown;
                if (d === undefined) {
                    // Fallback: Use PnL if negative? 
                    // Better to use 0 if unknown to avoid false positives?
                    // Or if PnL is -5000, DD was at least -5000.
                    d = t.pnl < 0 ? t.pnl : 0;
                }
                return d <= target;
            }).length;

            const total = parsedTrades.length;
            const pct = ((count / total) * 100).toFixed(1);

            resEl.textContent = `${count} / ${total} Trades`;
            pctEl.textContent = `${pct}% Hit Target`;
        }
    </script>
</body>

</html>